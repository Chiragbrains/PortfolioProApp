// /SetupScreen.js (New File)
import React, { useState } from 'react';
import { View, Text, TextInput, Button, StyleSheet, ActivityIndicator, Alert, ScrollView, Linking, TouchableOpacity, Modal, Platform, Clipboard } from 'react-native'; // Added Clipboard
import { useSupabaseConfig } from './SupabaseConfigContext';
import Markdown from 'react-native-markdown-display';
// Removed: import * as FileSystem from 'expo-file-system';
// Removed: import { Platform } from 'react-native'; // No longer needed for this

// --- Bundled README Content ---
// Removed the import: import readmeContentRaw from './README.md';

// Paste the full content of your README.md file here inside the backticks:
// --- Split Markdown Content ---
// We'll split the content around the collapsible blocks

const readmePart1 = `# Setting Up Your Supabase Database Project for the Portfolio Pro App

**Welcome & How It Works**

Welcome to the Portfolio Pro Tracker! This application is designed to help you monitor your stock and ETF investments directly from your device (web or mobile).

*   **Your Data, Your Database:** Unlike many apps, this one connects *directly* to **your own private Supabase project**. Supabase provides a standard, secure PostgreSQL database that you control.
*   **No App Hosting Needed:** You **do not** need to host the application code itself. You only need to set up the free Supabase database by following the steps below. The app runs locally in your browser or on your device.
*   **Privacy Focused:** Your portfolio data and Supabase credentials (URL, Anon Key) are stored locally on your device/browser and are **never** sent to any central server managed by the app developer.

**High-Level Features:**

*   Track stock, ETF, and cash positions across multiple accounts.
*   View consolidated portfolio summaries and performance (P&L, percentages).
*   Group and view holdings by brokerage account.
*   Visualize your portfolio's value over time with a history chart.
*   Import your holdings easily from an Excel file.
*   Automatic background data refresh (via your Supabase Edge Function and Cron Job).

**Important Note on Data Refresh:** This application is designed to be efficient. It will only attempt to fetch fresh stock prices from Yahoo Finance via the Edge Function if the last data refresh (recorded in your \`portfolio_history\` table) was more than 2 hours ago. Otherwise, it will use the most recently cached prices stored in your \`portfolio_summary\` table. The scheduled task (Cron Job) in Step 5 ensures this data is updated automatically in the background, even when you are not using the app.

---

## Setup Supabase DB Guide

Follow these steps carefully to create and configure your own Supabase database.

**Estimated Time:** 15-20 minutes

**Prerequisites:** A Supabase account (free tier is sufficient). Sign up at supabase.com.

---

### Step 1: Create a New Supabase Project

1.  Log in to your Supabase account.
2.  Click on "**New project**".
3.  Choose an organization.
4.  Enter a **Project Name** (e.g., "My Portfolio Pro").
5.  Generate or enter a secure **Database Password** (save this somewhere safe, though the app won't need it directly).
6.  Select a **Region** closest to you.
7.  Choose the **Free Plan**.
8.  Click "**Create new project**" and wait for it to be set up.

---

### Step 2: Create Required Database Tables & RPC Function

You need to create three tables (\`investment_accounts\`, \`portfolio_summary\`, \`portfolio_history\`) and a helper function in your Supabase PostgreSQL database.

1.  Once your project is ready, navigate to the **SQL Editor** in the left sidebar.
2.  Click "**New query**".
3.  Copy the entire SQL code block below, paste it into the query editor, and click "**RUN**".

`; // End of Part 1

const sqlBlock1_preview = `\`\`\`sql
    -- 1. Create the 'investment_accounts' table to hold your portfolio positions
    -- Renamed to 'investment_accounts' to store individual transactions
    CREATE TABLE public.investment_accounts (
      id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
      created_at timestamp with time zone DEFAULT now() NOT NULL,
      ticker text NOT NULL,
      account text NOT NULL,
      quantity numeric NOT NULL,
      cost_basis numeric NOT NULL,
    ); -- ... (more below)
\`\`\``; // End of SQL Block 1 Preview
const sqlBlock1_full = `\`\`\`sql
    -- Add comments for clarity (optional)
    COMMENT ON TABLE public.investment_accounts IS 'Stores individual buy/sell transactions for all accounts.';

    -- Note: A unique constraint on (ticker, account) might not be suitable for a transaction table.
    -- Remove or adjust if multiple transactions for the same ticker/account are expected.
    -- ALTER TABLE public.investment_accounts
    --   ADD CONSTRAINT investment_accounts_ticker_account_unique UNIQUE (ticker, account);

    -- 2. Create the 'portfolio_summary' table to store aggregated positions and cached prices
    -- Replaces the old 'stock_cache' and provides a summarized view instead of just prices
    CREATE TABLE public.portfolio_summary (
      ticker text PRIMARY KEY, -- Unique identifier for the stock/asset
      company_name text, -- Name of the company/asset
      total_quantity numeric,
      average_cost_basis numeric,
      current_price numeric,
      total_cost_basis_value numeric, -- Total cost basis (avg_cost * quantity)
      market_value numeric,
      pnl_dollar numeric, -- Profit/Loss in currency
      pnl_percent numeric, -- Profit/Loss in percentage
      portfolio_percent numeric, -- Percentage of the total portfolio value
      type text, -- Type of asset (e.g., 'stock', 'etf', 'cash')
      last_updated timestamp with time zone -- When the price/data was last updated
    );
    COMMENT ON TABLE public.portfolio_summary IS 'Aggregated view of holdings per ticker, including cached prices and performance metrics.';

    -- 3. Create the 'portfolio_history' table for daily snapshots
    CREATE TABLE public.portfolio_history (
      id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
      date date NOT NULL,
      total_value numeric, -- Represents total portfolio value (adjust based on Edge Function logic)
      total_cost_basis numeric, -- Represents total cost basis (adjust based on Edge Function logic)
      total_pnl numeric, -- Represents overall P&L (adjust based on Edge Function logic)
      cash_value numeric, -- Stores the cash value separately if applicable
      created_at timestamp with time zone DEFAULT now() NOT NULL -- Tracks when the snapshot was last updated/created
    );

    -- Add a unique constraint on the date column for daily upserts
    ALTER TABLE public.portfolio_history
      ADD CONSTRAINT portfolio_history_date_unique UNIQUE (date);

    -- 4. Create the truncate_investment_accounts function needed by the app
    -- This allows truncating the table via RPC without granting full DELETE privileges
    CREATE OR REPLACE FUNCTION truncate_investment_accounts()
    RETURNS void AS $$
    BEGIN
      TRUNCATE TABLE investment_accounts RESTART IDENTITY CASCADE;
    END;
    $$ LANGUAGE plpgsql SECURITY DEFINER;
\`\`\``; // End of SQL Block 1 Full

const readmePart2 = `

4.  Verify that the query ran successfully and the three tables (\`investment_accounts\`, \`portfolio_summary\`, \`portfolio_history\`) appear in the **Table Editor**.

---

### Step 3: Enable Row Level Security (RLS) and Create Policies

RLS protects your data. These policies allow the app (using your public \`anon\` key) to access the data it needs.

1.  In the left sidebar, navigate to the **SQL Editor**.
2.  Click "**New query**".
3.  Copy the entire SQL code block below, paste it into the query editor, and click "**RUN**".

`; // End of Part 2

const sqlBlock2_preview = `\`\`\`sql
    -- Enable RLS for each table
    ALTER TABLE public.investment_accounts ENABLE ROW LEVEL SECURITY;
    ALTER TABLE public.portfolio_summary ENABLE ROW LEVEL SECURITY;
    ALTER TABLE public.portfolio_history ENABLE ROW LEVEL SECURITY;

    -- Grant permissions to the 'anon' role (used by the app)
    -- ... (more below)
\`\`\``; // End of SQL Block 2 Preview
const sqlBlock2_full = `\`\`\`sql
    -- Enable RLS for each table
    ALTER TABLE public.investment_accounts ENABLE ROW LEVEL SECURITY;
    ALTER TABLE public.portfolio_summary ENABLE ROW LEVEL SECURITY;
    ALTER TABLE public.portfolio_history ENABLE ROW LEVEL SECURITY;

    -- Grant permissions to the 'anon' role (used by the app)
    -- Note: 'public' role implicitly includes 'anon'

    -- Policies for 'investment_accounts' table (Allow all actions for simplicity - REVIEW THIS)
    -- Consider if more restrictive policies are needed (e.g., based on user ID if you add authentication)
    CREATE POLICY "Allow ALL access on investment_accounts"
      ON public.investment_accounts
      FOR ALL -- Covers SELECT, INSERT, UPDATE, DELETE
      USING (true) -- Allows the action if this condition is true
      WITH CHECK (true); -- Enforces this condition on INSERT/UPDATE

    -- Policies for 'portfolio_summary' table (Allow read, insert, update)
    CREATE POLICY "Allow read access on portfolio_summary"
      ON public.portfolio_summary
      FOR SELECT
      USING (true);

    CREATE POLICY "Allow insert/update access on portfolio_summary"
      ON public.portfolio_summary
      FOR ALL -- Covers INSERT, UPDATE (needed for upsert)
      USING (true)
      WITH CHECK (true);

    -- Policies for 'portfolio_history' table (Allow read, insert, update)
    CREATE POLICY "Allow read access on portfolio_history"
      ON public.portfolio_history
      FOR SELECT
      USING (true);

    CREATE POLICY "Allow insert/update access on portfolio_history"
      ON public.portfolio_history
      FOR ALL -- Covers INSERT, UPDATE (needed for upsert)
      USING (true)
      WITH CHECK (true);

    -- Grant usage on schema and sequences if needed (often default, but good practice)
    GRANT USAGE ON SCHEMA public TO anon;
    GRANT ALL ON ALL TABLES IN SCHEMA public TO anon;
    GRANT ALL ON ALL SEQUENCES IN SCHEMA public TO anon;
    GRANT ALL ON ALL FUNCTIONS IN SCHEMA public TO anon; -- If using RPC functions accessible by anon
\`\`\``; // End of SQL Block 2 Full

const readmePart3 = `

4.  Verify that the query ran successfully. You can double-check in **Authentication** -> **Policies** that RLS is enabled for the tables and policies exist.

---

### Step 4: Create the Supabase Edge Function

This function runs on Supabase servers to fetch live stock prices and update your cache and history.

1.  In the left sidebar, navigate to **Edge Functions**.
2.  Click "**Deploy a new function**" - via Editor
3.  Enter the **Function name**: \`portfolio-processor\` (use this exact name) at bottom right.
4.  You'll be shown an editor with default code. **Delete all the default code**.
5.  **Copy the entire Edge Function code provided below** and paste it into the editor:

`; // End of Part 3

const edgeFunctionBlock_preview = `\`\`\`typescript
    // --- PASTE YOUR EDGE FUNCTION CODE HERE ---
    import { serve } from 'https://deno.land/std@0.177.0/http/server.ts';
    import { createClient } from 'https://esm.sh/@supabase/supabase-js@2'; // Added SupabaseClient type
    import { corsHeaders } from '../_shared/cors.ts';
    // --- Configuration ---
    const YAHOO_FINANCE_API_BASE = 'https://query1.finance.yahoo.com/v8/finance/chart/';
    const CACHE_FRESHNESS_HOURS = 2;
    // ... (more below)
\`\`\``; // End of Edge Function Block Preview
const edgeFunctionBlock_full = `\`\`\`typescript
    // --- PASTE YOUR EDGE FUNCTION CODE HERE ---
    import { serve } from 'https://deno.land/std@0.177.0/http/server.ts';
    import { createClient } from 'https://esm.sh/@supabase/supabase-js@2'; // Added SupabaseClient type
    import { corsHeaders } from '../_shared/cors.ts';
    // --- Configuration ---
    const YAHOO_FINANCE_API_BASE = 'https://query1.finance.yahoo.com/v8/finance/chart/';
    const CACHE_FRESHNESS_HOURS = 2;
    const USER_AGENT = 'MyStockPortfolioApp/1.0 (Supabase Edge Function)';
    // --- Helper Functions (Keep exactly as they were) ---
    function mapInstrumentType(instrumentType) {
      if (!instrumentType) return null;
      const lowerType = instrumentType.toLowerCase();
      if (lowerType === 'equity') return 'stock';
      if (lowerType === 'etf' || lowerType === 'mutualfund') return 'etf';
      // Add 'cash' mapping if needed, though usually handled separately
      // if (lowerType === 'cash') return 'cash';
      return null;
    }
    async function updateStockCache(supabaseClient, ticker, currentPrice, companyName, type) {
      try {
        const utcTimestamp = new Date().toISOString();
        const { error } = await supabaseClient.from('stock_cache').upsert({
          ticker,
          current_price: currentPrice,
          company_name: companyName,
          type: type,
          last_refreshed: utcTimestamp
        }, {
          onConflict: 'ticker'
        });
        if (error) console.error(\`Cache update error for \${ticker}:\`, error.message);
        else console.log(\`Cache updated for \${ticker}\`);
      } catch (error) {
        console.error(\`Cache update exception for \${ticker}:\`, error.message);
      }
    }
    async function fetchFromCache(supabaseClient, ticker, ignoreAge = false) {
      const defaultReturn = {
        price: null,
        name: null,
        type: null,
        last_refreshed: null
      };
      try {
        const { data, error } = await supabaseClient.from('stock_cache').select('current_price, company_name, type, last_refreshed').eq('ticker', ticker).maybeSingle();
        if (error) {
          console.error(\`Cache fetch error for \${ticker}:\`, error.message);
          return defaultReturn;
        }
        if (data?.current_price !== null && data?.last_refreshed) {
          const cacheTime = new Date(data.last_refreshed);
          const currentTime = new Date();
          const cacheAgeHours = (currentTime.getTime() - cacheTime.getTime()) / (1000 * 60 * 60);
          if (ignoreAge || cacheAgeHours < CACHE_FRESHNESS_HOURS) {
            const reason = ignoreAge ? 'ignoring age' : \`fresh (\${cacheAgeHours.toFixed(2)} hrs old)\`;
            console.log(\`Using cached data for \${ticker} (\${reason})\`);
            return {
              price: data.current_price,
              name: data.company_name,
              type: data.type,
              last_refreshed: data.last_refreshed
            };
          } else {
            console.log(\`Cache for \${ticker} outdated (\${cacheAgeHours.toFixed(2)} hrs old).\`);
            // Return stale meta even if price is outdated
            return {
              price: null,
              name: data.company_name,
              type: data.type,
              last_refreshed: data.last_refreshed
            };
          }
        }
        return defaultReturn;
      } catch (cacheError) {
        console.error(\`Cache fetch exception for \${ticker}:\`, cacheError.message);
        return defaultReturn;
      }
    }
    async function fetchCurrentPriceAndMeta(supabaseClient, ticker) {
      // Try fresh cache first
      let cachedData = await fetchFromCache(supabaseClient, ticker, false);
      if (cachedData.price !== null) {
        return {
          price: cachedData.price,
          name: cachedData.name,
          type: cachedData.type
        };
      }
      // Price not fresh or not found, try fetching from Yahoo
      let fetchedPrice = null;
      let fetchedName = cachedData.name; // Keep stale name as fallback
      let fetchedType = cachedData.type; // Keep stale type as fallback
      let nameFromYahoo = null;
      let typeFromYahoo = null;
      try {
        const url = \`\${YAHOO_FINANCE_API_BASE}\${ticker}\`;
        console.log(\`Fetching URL: \${url}\`);
        const response = await fetch(url, {
          headers: {
            'User-Agent': USER_AGENT
          }
        });
        if (response.ok) {
          const data = await response.json();
          const meta = data?.chart?.result?.[0]?.meta;
          // Extract Name
          if (meta?.shortName) nameFromYahoo = meta.shortName;
          else if (meta?.longName) nameFromYahoo = meta.longName;
          if (nameFromYahoo !== null) fetchedName = nameFromYahoo; // Prefer Yahoo name
          // Extract Type
          if (meta?.instrumentType) typeFromYahoo = mapInstrumentType(meta.instrumentType);
          if (typeFromYahoo !== null) fetchedType = typeFromYahoo; // Prefer Yahoo type
          // Extract Price (prefer regularMarketPrice, fallback to close)
          const regularMarketPrice = meta?.regularMarketPrice;
          const closePriceArray = data?.chart?.result?.[0]?.indicators?.quote?.[0]?.close;
          const lastClosePrice = closePriceArray?.[closePriceArray.length - 1]; // Get the last available close price
          if (typeof regularMarketPrice === 'number' && regularMarketPrice > 0) {
            fetchedPrice = regularMarketPrice;
          } else if (typeof lastClosePrice === 'number' && lastClosePrice > 0) {
            fetchedPrice = lastClosePrice;
            console.log(\`Using last close price for \${ticker}: \${fetchedPrice}\`);
          }
          if (fetchedPrice !== null) {
            console.log(\`Fetched from Yahoo for \${ticker}: Price=\$\${fetchedPrice}, Name=\${fetchedName}, Type=\${fetchedType}\`);
            // Update cache with fresh data
            await updateStockCache(supabaseClient, ticker, fetchedPrice, fetchedName, fetchedType);
            return {
              price: fetchedPrice,
              name: fetchedName,
              type: fetchedType
            };
          } else {
            console.warn(\`No valid price found for \${ticker} in Yahoo response.\`);
          }
        } else {
          console.error(\`Yahoo fetch error for \${ticker}: \${response.status} \${response.statusText}\`);
        }
      } catch (error) {
        console.error(\`Yahoo fetch/processing error for \${ticker}:\`, error);
      }
      // If Yahoo fetch failed or returned no price, try using stale cache price
      if (fetchedPrice === null) {
        console.log(\`Yahoo fetch failed for \${ticker}. Trying stale cache price.\`);
        cachedData = await fetchFromCache(supabaseClient, ticker, true); // Ignore age
        if (cachedData.price !== null) {
          // Use the name/type determined during the Yahoo attempt (which might be stale or from Yahoo)
          console.log(\`Using stale cache price for \${ticker}: \${cachedData.price}, Name: \${fetchedName}, Type: \${fetchedType}\`);
          // Update cache with stale price but potentially updated meta
          await updateStockCache(supabaseClient, ticker, cachedData.price, fetchedName, fetchedType);
          return {
            price: cachedData.price,
            name: fetchedName,
            type: fetchedType
          };
        }
      }
      // Absolute fallback if no price could be determined
      console.error(\`Could not determine price for \${ticker}. Returning null price.\`);
      return {
        price: null,
        name: fetchedName,
        type: fetchedType
      }; // Return potentially stale meta even if price is null
    }
    // --- End Helper Functions ---
    // --- Main Request Handler ---
    serve(async (req)=>{
      // Handle CORS preflight request
      if (req.method === 'OPTIONS') {
        return new Response('ok', {
          headers: corsHeaders
        });
      }
      try {
        // --- Initialize Supabase Client ---
        const supabaseUrl = Deno.env.get('SUPABASE_URL');
        const supabaseServiceKey = Deno.env.get('SUPABASE_SERVICE_ROLE_KEY'); // Use the SERVICE ROLE KEY
        if (!supabaseUrl || !supabaseServiceKey) {
          throw new Error('Missing Supabase environment variables.');
        }
        // Use service role key for admin-level access needed for updates/deletes
        const supabaseClient = createClient(supabaseUrl, supabaseServiceKey, {
          auth: {
            // Required for service role key
            persistSession: false,
            autoRefreshToken: false,
            detectSessionInUrl: false
          }
        });
        // --- 1. Fetch all transactions from investment_accounts ---
        console.log("Fetching transactions from investment_accounts...");
        const { data: transactions, error: fetchError } = await supabaseClient.from('investment_accounts').select('id, ticker, account, quantity, cost_basis, created_at'); // Select necessary fields
        if (fetchError) {
          throw new Error(\`Failed to fetch investment accounts: \${fetchError.message}\`);
        }
        const currentTimestamp = new Date().toISOString();
        let overallMarketValue = 0;
        let overallCostBasisValue = 0;
        let overallCashValue = 0;
        let tickerSummaries = []; // Define outside the conditional blocks
        // --- 2. Handle Empty Transactions (Clear All Scenario) ---
        if (!transactions || transactions.length === 0) {
          console.log("No investment transactions found. Zeroing out portfolio_summary.");
          // Fetch existing tickers from portfolio_summary to preserve them
          const { data: existingSummaries, error: fetchExistingError } = await supabaseClient.from('portfolio_summary').select('ticker, company_name, current_price, type'); // Select fields to keep
          if (fetchExistingError) {
            console.error("Error fetching existing summary tickers:", fetchExistingError);
            // Decide if you want to throw or continue (maybe log and proceed with empty history)
            throw new Error(\`Failed to fetch existing summaries: \${fetchExistingError.message}\`);
          }
          if (existingSummaries && existingSummaries.length > 0) {
            // Prepare updates to zero out financial fields
            const zeroedSummaries = existingSummaries.map((existing)=>({
                ticker: existing.ticker,
                company_name: existing.company_name,
                total_quantity: 0,
                average_cost_basis: 0,
                current_price: existing.current_price,
                total_cost_basis_value: 0,
                market_value: 0,
                pnl_dollar: 0,
                pnl_percent: 0,
                portfolio_percent: 0,
                type: existing.type,
                last_updated: currentTimestamp
              }));
            // Upsert the zeroed-out summaries
            console.log(\`Upserting \${zeroedSummaries.length} zeroed summary rows...\`);
            const { error: upsertError } = await supabaseClient.from('portfolio_summary').upsert(zeroedSummaries, {
              onConflict: 'ticker'
            });
            if (upsertError) {
              console.error("Error upserting zeroed summaries:", upsertError);
            // Log error but continue to update history
            } else {
              console.log("Successfully zeroed out summary rows.");
            }
          } else {
            console.log("No existing summaries found to zero out.");
          }
        // Note: overallMarketValue, overallCostBasisValue, overallCashValue remain 0
        } else {
          // --- 3. Process Non-Empty Transactions (Existing Logic) ---
          console.log(\`Fetched \${transactions.length} transactions. Processing...\`);
          // --- 3a. Consolidate transactions by ticker ---
          console.log("Consolidating transactions by ticker...");
          const consolidatedMap = new Map();
          for (const tx of transactions){
            const ticker = tx.ticker?.toUpperCase() ?? 'UNKNOWN';
            const quantity = tx.quantity ?? 0;
            const costBasis = tx.cost_basis ?? 0;
            const existing = consolidatedMap.get(ticker) ?? {
              totalQuantity: 0,
              totalCostValue: 0
            };
            existing.totalQuantity += quantity;
            // Only add cost for positive quantity (buys/adds)
            if (quantity > 0) {
              existing.totalCostValue += quantity * costBasis;
            }
            // Note: Simple weighted average cost. Sells require more complex logic (FIFO/LIFO etc.)
            consolidatedMap.set(ticker, existing);
          }
          console.log(\`Consolidated into \${consolidatedMap.size} unique tickers.\`);
          // --- 3b. Fetch prices/meta and calculate initial summary ---
          console.log("Fetching prices and calculating summaries...");
          for (const [ticker, consolidated] of consolidatedMap.entries()){
            const { totalQuantity, totalCostValue } = consolidated;
            // Skip tickers with zero or negative quantity after consolidation
            if (totalQuantity <= 0) {
              console.log(\`Skipping ticker \${ticker} due to zero or negative quantity (\${totalQuantity}).\`);
              continue; // Skip to next ticker
            }
            let metaResult;
            let finalType;
            if (ticker === 'CASH') {
              metaResult = {
                price: 1.0,
                name: 'Cash',
                type: null
              };
              finalType = 'cash';
              overallCashValue += totalQuantity; // Accumulate cash value
            } else {
              metaResult = await fetchCurrentPriceAndMeta(supabaseClient, ticker);
              finalType = metaResult.type; // Use type determined from Yahoo/cache
            }
            const currentPrice = metaResult.price;
            const marketValue = currentPrice !== null ? currentPrice * totalQuantity : 0;
            const averageCostBasis = totalQuantity > 0 ? totalCostValue / totalQuantity : 0; // Weighted average cost
            const pnlDollar = marketValue - totalCostValue;
            const pnlPercent = totalCostValue > 0 ? pnlDollar / totalCostValue * 100 : 0;
            tickerSummaries.push({
              ticker: ticker,
              company_name: metaResult.name,
              total_quantity: totalQuantity,
              average_cost_basis: averageCostBasis,
              current_price: currentPrice,
              total_cost_basis_value: totalCostValue,
              market_value: marketValue,
              pnl_dollar: pnlDollar,
              pnl_percent: pnlPercent,
              portfolio_percent: 0,
              type: finalType,
              last_updated: currentTimestamp
            });
            overallMarketValue += marketValue; // Accumulate total market value
            overallCostBasisValue += totalCostValue; // Accumulate total cost basis
          }
          console.log("Finished initial summary calculations.");
          // --- 3c. Calculate portfolio percentage ---
          console.log("Calculating portfolio percentages...");
          tickerSummaries.forEach((summary)=>{
            summary.portfolio_percent = overallMarketValue > 0 ? summary.market_value / overallMarketValue * 100 : 0;
          });
          // --- 3d. Upsert summaries into portfolio_summary table ---
          console.log(\`Upserting \${tickerSummaries.length} rows into portfolio_summary...\`);
          // Delete tickers from summary table that are no longer present (have zero quantity)
          const currentTickers = tickerSummaries.map((s)=>s.ticker);
          if (currentTickers.length > 0) {
            const { error: deleteError } = await supabaseClient.from('portfolio_summary').delete().not('ticker', 'in', \`(\${currentTickers.map((t)=>\`'\${t}'\`).join(',')})\`); // Delete where ticker NOT IN current list
            if (deleteError) {
              console.error("Error deleting old summary rows:", deleteError);
            // Log error but continue
            } else {
              console.log("Deleted obsolete summary rows (if any).");
            }
          } else {
            // If no current tickers with positive quantity, delete all summary rows (shouldn't happen if CASH exists)
            console.warn("No tickers with positive quantity found after consolidation. Deleting all summary rows.");
            const { error: deleteAllError } = await supabaseClient.from('portfolio_summary').delete().neq('ticker', 'DUMMY_VALUE_TO_DELETE_ALL'); // Delete all
            if (deleteAllError) {
              console.error("Error deleting all summary rows:", deleteAllError);
            }
          }
          // Upsert the current summaries
          if (tickerSummaries.length > 0) {
            const { data: summaryUpsertData, error: summaryUpsertError } = await supabaseClient.from('portfolio_summary').upsert(tickerSummaries, {
              onConflict: 'ticker'
            }).select('ticker'); // Select only ticker for brevity
            if (summaryUpsertError) {
              throw new Error(\`Failed to save portfolio summary: \${summaryUpsertError.message}\`);
            }
            console.log(\`Successfully upserted \${summaryUpsertData?.length ?? 0} rows into portfolio_summary.\`);
          } else {
            console.log("No valid ticker summaries to upsert.");
          }
        } // End of else block (processing non-empty transactions)
        // --- 4. Update portfolio_history table (Always runs, uses calculated totals) ---
        const overallPnl = overallMarketValue - overallCostBasisValue;
        const historySnapshotData = {
          date: currentTimestamp.split('T')[0],
          total_value: overallMarketValue,
          total_cost_basis: overallCostBasisValue,
          total_pnl: overallPnl,
          cash_value: overallCashValue,
          created_at: currentTimestamp
        };
        console.log('Upserting portfolio_history snapshot:', JSON.stringify(historySnapshotData));
        const { error: historyUpsertError } = await supabaseClient.from('portfolio_history').upsert(historySnapshotData, {
          onConflict: 'date'
        }); // Upsert based on date
        if (historyUpsertError) {
          // Warn instead of throwing, as history update is secondary
          console.warn(\`Failed to save portfolio history snapshot: \${historyUpsertError.message}\`);
        } else {
          console.log("Successfully upserted portfolio_history snapshot.");
        }
        // --- 5. Return success response ---
        return new Response(JSON.stringify({
          success: true,
          summaryCount: tickerSummaries.length,
          message: transactions && transactions.length > 0 ? 'Portfolio processed.' : 'Portfolio zeroed out.'
        }), {
          headers: {
            ...corsHeaders,
            'Content-Type': 'application/json'
          },
          status: 200
        });
      } catch (error) {
        // Catch any errors from the main try block
        console.error('Error in Edge Function:', error);
        return new Response(JSON.stringify({
          error: error.message
        }), {
          headers: {
            ...corsHeaders,
            'Content-Type': 'application/json'
          },
          status: 500
        });
      }
    });
    // --- END OF EDGE FUNCTION CODE ---
\`\`\``; // End of Edge Function Block Full

const readmePart4 = `

7.  Click "**Save and Deploy**" (or Deploy). Wait for the deployment to complete.
8.  **Set Environment Variables:**
    *   Go to **Project Settings** -> **Edge Functions**.
    *   Add below **Edge Function Secrets**.
    *   Add \`SUPABASE_URL\`: Find this in **Project Settings** -> **API** -> **Project URL**.
    *   Add \`SUPABASE_SERVICE_ROLE_KEY\`: Find this in **Project Settings** -> **API** -> **Project API keys** -> \`service_role\` key (**Keep this secret!**).
    *   Click "**Save**".

---

### Step 5: Schedule the Edge Function (Cron Job via Dashboard)

This automatically runs your Edge Function (e.g., daily or every few hours) **to keep price data fresh and build the data needed for the history chart, even when you are not using the application.**

1.  In the left sidebar, navigate to **Database** -> **Functions**.
2.  Click "**New cron job**". - go here if you can't find (https://supabase.com/dashboard/project/vdxrsbzfqucnlfxlkhdu/integrations/cron/jobs)
3.  Fill in the details:
    *   **Name:** Enter a descriptive name, e.g., \`invoke-portfolio-processor\`.
    *   **Schedule:** Enter your desired schedule using standard cron syntax.
        *   Example: \`0 */4 * * *\` (Runs every 4 hours at the start of the hour).
        *   Example: \`0 2 * * *\` (Runs once a day at 2 AM UTC).
        *   Use natural language or crontab.guru to help build your schedule. Be mindful of free tier invocation limits.
    *   **Function Hook:** Select \`HTTP Request\`.
    *   **Method:** Select \`POST\`.
    *   **URL:** Enter your Edge Function URL:
        *   Format: \`[YOUR SUPABASE PROJECT URL]/functions/v1/portfolio-processor\`
        *   Replace \`[YOUR SUPABASE PROJECT URL]\` with your actual Project URL (from Step 4 or Step 6).
    *   **Headers:**
        *   Click "**Add Header**".
        *   **Name:** \`Authorization\`
        *   **Value:** \`Bearer [YOUR SUPABASE SERVICE ROLE KEY]\`
        *   Replace \`[YOUR SUPABASE SERVICE ROLE KEY]\` with your actual \`service_role\` key (from Step 4 or Step 6). **Keep this key secure.**
    *   **Body:** Leave this as the default empty JSON object \`{}\` unless your function specifically requires a body.
4.  Review the details carefully.
5.  Click "**Create cron job**".

---

### Step 6: Find Your Project URL and Anon Key

The application needs these to connect to *your* Supabase project.

1.  In the left sidebar, go to **Project Settings** (the gear icon).
2.  Select **API**.
3.  Under **Project API keys**:
    *   Copy the **URL**. This is your Supabase Project URL.
    *   Copy the **\`anon\` \`public\`** key. This is your Supabase Anon Key.
    *   Save in browser for easy access
4.  Keep these copied values ready for the next step. **Do not use the \`service_role\` key in the app.**

---

### Step 7: Enter Credentials in the Portfolio Pro App

1.  Open the Portfolio Pro App.
2.  You should see a setup screen asking for your Supabase details.
3.  Carefully paste the **Project URL** you copied into the "Supabase Project URL" field.
4.  Carefully paste the **Anon Key** you copied into the "Supabase Anon Key" field.
5.  Click "**Connect & Save**".

---

**Setup Complete!**

If the connection is successful, the app should load and function using your own Supabase database. If you encounter errors, double-check that you copied the URL and Anon Key correctly and that all tables, RLS policies, and the Edge Function were set up exactly as described. Check the Edge Function logs and Cron Job history in your Supabase dashboard for troubleshooting.
`; // <-- Make sure this closing backtick and semicolon are present!
// --- End of Split Content ---

const SetupScreen = () => {
  const [url, setUrl] = useState('');
  const [anonKey, setAnonKey] = useState('');
  const { saveConfig, isLoading, configError } = useSupabaseConfig();
  const [modalVisible, setModalVisible] = useState(false);
  // State for collapsible sections
  const [sql1Visible, setSql1Visible] = useState(false);
  const [sql2Visible, setSql2Visible] = useState(false);
  const [edgeFuncVisible, setEdgeFuncVisible] = useState(false);
  // State for copy feedback
  const [sql1Copied, setSql1Copied] = useState(false);
  const [sql2Copied, setSql2Copied] = useState(false);
  const [edgeFuncCopied, setEdgeFuncCopied] = useState(false);

  const handleConnect = async () => {
    const success = await saveConfig(url.trim(), anonKey.trim());
    if (!success) {
        // Error is handled and displayed via configError state in context
        Alert.alert("Connection Failed", configError || "Please check your URL and Anon Key and try again.");
    }
    // On success, the App component will automatically re-render the main view
  };

  // Simplified handler: Just show the modal with the bundled content
  const handleViewInstruction = () => {
    setModalVisible(true);
    // Reset visibility when opening modal
    setSql1Visible(false);
    setSql2Visible(false);
    setEdgeFuncVisible(false);

  };

  // Function to copy text to clipboard
  const handleCopy = (textToCopy, blockName) => {
    // Remove leading/trailing fences and trim whitespace for cleaner copy
    const cleanedText = textToCopy.replace(/^```[a-z]*\n?/, '').replace(/\n?```$/, '').trim();
    Clipboard.setString(textToCopy);
    // Alert.alert('Copied!', `${blockName} code copied to clipboard.`); // Removed Alert

    // Set temporary copied state based on blockName
    let setCopiedState;
    if (blockName === 'SQL Block 1') setCopiedState = setSql1Copied;
    else if (blockName === 'SQL Block 2') setCopiedState = setSql2Copied;
    else if (blockName === 'Edge Function') setCopiedState = setEdgeFuncCopied;

    if (setCopiedState) {
      setCopiedState(true);
      setTimeout(() => setCopiedState(false), 1500); // Reset after 1.5 seconds
    }
  };

  return (
    <ScrollView contentContainerStyle={styles.container}>
      <Text style={styles.title}>Connect to Your Supabase</Text>
      <Text style={styles.instructions}>
        Before using the app, you need to set up your own Supabase project.
        Follow the instructions provided (link below) to create the necessary tables and functions.
        Then, enter your Supabase Project URL and Anon Key below.
      </Text>

      <TextInput
        style={styles.input}
        placeholder="Supabase Project URL (e.g., https://xyz.supabase.co)"
        value={url}
        onChangeText={setUrl}
        autoCapitalize="none"
        keyboardType="url"
      />
      <TextInput
        style={styles.input}
        placeholder="Supabase Anon Key (public)"
        value={anonKey}
        onChangeText={setAnonKey}
        autoCapitalize="none"
        secureTextEntry={true} // Hide key slightly
      />

      {isLoading && <ActivityIndicator size="large" color="#0066cc" />}
      {configError && <Text style={styles.errorText}>{configError}</Text>}

      <Button title={isLoading ? "Connecting..." : "Connect & Save"} onPress={handleConnect} disabled={isLoading} />

      <Text style={styles.privacyNote}>
          Your URL and Anon Key are stored only in your browser's local storage and are not sent to our servers.
          Ensure you have enabled Row Level Security on your Supabase tables.
      </Text>

      <Button title="View Instruction" onPress={handleViewInstruction} />

      {/* Make modal transparent and use an inner container for styling */}
      <Modal
        visible={modalVisible}
        animationType="fade" // Fade looks better for non-fullscreen modals
        onRequestClose={() => setModalVisible(false)}
        transparent={true} // Make modal background transparent
      >
        {/* Outer view for overlay effect and centering */}
        <View style={styles.modalOverlay}>
          {/* Inner container for the actual modal content */}
          <View style={styles.modalInnerContainer}>
            {/* Header with close button */}
            <View style={styles.modalHeader}>
              <TouchableOpacity onPress={() => setModalVisible(false)} style={styles.modalCloseButton}>
                <Text style={styles.modalCloseButtonText}>✕</Text>
              </TouchableOpacity>
            </View>
            {/* Scrollable content area */}
            <ScrollView style={styles.modalScrollView}>
          <Markdown style={markdownStyles}>{readmePart1}</Markdown>

          {/* SQL Block 1 - Wrapper for positioning */}
          <View style={styles.codeBlockWrapper}>
            <Markdown style={markdownStyles}>
              {sql1Visible ? sqlBlock1_full : sqlBlock1_preview}
            </Markdown>
            <TouchableOpacity style={styles.copyButton} onPress={() => handleCopy(sqlBlock1_full, 'SQL Block 1')}>
              <Text style={[styles.copyButtonText, sql1Copied && styles.copiedText]}>
                {sql1Copied ? 'Copied!' : '⎘'}
              </Text>
            </TouchableOpacity>
          </View>
          {/* Button Row */}
          <View style={styles.buttonRow}>
            <TouchableOpacity style={styles.toggleButton} onPress={() => setSql1Visible(!sql1Visible)}>
              <Text style={styles.toggleButtonText}>{sql1Visible ? 'Show Less' : 'Show More (Tables & Function)'}</Text>
            </TouchableOpacity>
            {/* Removed duplicate copy button */}
          </View>
          
          <Markdown style={markdownStyles}>{readmePart2}</Markdown>

          {/* SQL Block 2 - Wrapper for positioning */}
          <View style={styles.codeBlockWrapper}>
            <Markdown style={markdownStyles}>
              {sql2Visible ? sqlBlock2_full : sqlBlock2_preview}
            </Markdown>
            <TouchableOpacity style={styles.copyButton} onPress={() => handleCopy(sqlBlock2_full, 'SQL Block 2')}>
              <Text style={[styles.copyButtonText, sql2Copied && styles.copiedText]}>
                {sql2Copied ? 'Copied!' : '⎘'}
              </Text>
            </TouchableOpacity>
          </View>
          {/* Button Row */}
          <View style={styles.buttonRow}>
            <TouchableOpacity style={styles.toggleButton} onPress={() => setSql2Visible(!sql2Visible)}>
              <Text style={styles.toggleButtonText}>{sql2Visible ? 'Show Less' : 'Show More (RLS Policies)'}</Text>
            </TouchableOpacity>
            {/* Removed duplicate copy button */}
          </View>

          <Markdown style={markdownStyles}>{readmePart3}</Markdown>

          {/* Edge Function Block - Wrapper for positioning */}
          <View style={styles.codeBlockWrapper}>
            <Markdown style={markdownStyles}>
              {edgeFuncVisible ? edgeFunctionBlock_full : edgeFunctionBlock_preview}
            </Markdown>
            <TouchableOpacity style={styles.copyButton} onPress={() => handleCopy(edgeFunctionBlock_full, 'Edge Function')}>
              <Text style={[styles.copyButtonText, edgeFuncCopied && styles.copiedText]}>
                {edgeFuncCopied ? 'Copied!' : '⎘'}
              </Text>
            </TouchableOpacity>
          </View>
          {/* Button Row */}
          <View style={styles.buttonRow}>
            <TouchableOpacity style={styles.toggleButton} onPress={() => setEdgeFuncVisible(!edgeFuncVisible)}>
              <Text style={styles.toggleButtonText}>{edgeFuncVisible ? 'Show Less' : 'Show More (Edge Function)'}</Text>
            </TouchableOpacity>
            {/* Removed duplicate copy button */}
          </View>

          <Markdown style={markdownStyles}>{readmePart4}</Markdown>
            </ScrollView>
            {/* Optional: Keep the bottom close button or remove it */}
            {/* <Button title="Close" onPress={() => setModalVisible(false)} /> */}
          </View>
        </View>
      </Modal>
    </ScrollView>
  );
};

const styles = StyleSheet.create({
    container: {
        flexGrow: 1,
        justifyContent: 'center',
        alignItems: 'center',
        padding: 20,
        backgroundColor: '#f5f5f5',
    },
    title: {
        fontSize: 24,
        fontWeight: 'bold',
        marginBottom: 15,
        textAlign: 'center',
    },
    instructions: {
        textAlign: 'center',
        marginBottom: 20,
        color: '#333',
        lineHeight: 20,
    },
    link: {
        color: '#0066cc',
        textDecorationLine: 'underline',
        marginBottom: 20,
    },
    input: {
        width: '100%',
        height: 50,
        borderColor: '#ccc',
        borderWidth: 1,
        borderRadius: 8,
        paddingHorizontal: 15,
        marginBottom: 15,
        backgroundColor: 'white',
    },
    errorText: {
        color: 'red',
        marginBottom: 10,
        textAlign: 'center',
    },
    privacyNote: {
        marginTop: 25,
        fontSize: 12,
        color: '#666',
        textAlign: 'center',
        fontStyle: 'italic',
    },
    // Style for the toggle button
    buttonRow: { // Container for toggle and copy buttons
        flexDirection: 'row',
        justifyContent: 'space-between', // Space out buttons
        alignItems: 'center',
        marginVertical: 10,
    },
    toggleButton: {
        backgroundColor: '#e7f0f7', // Light blue background
        paddingVertical: 8,
        paddingHorizontal: 12,
        borderRadius: 6,
        // marginVertical: 10, // Moved margin to buttonRow
        alignItems: 'center',
        flexGrow: 1, // Allow toggle button to grow
        marginRight: 10, // Space between buttons
    },
    toggleButtonText: {
        color: '#0056b3', // Darker blue text
        fontWeight: '500',
    },
    codeBlockWrapper: { // New wrapper for Markdown + Copy Button
        position: 'relative', // Needed for absolute positioning of children
        marginVertical: 10, // Keep the vertical margin here
    },
    copyButton: { // Style for the new copy button
        position: 'absolute', // Position relative to codeBlockWrapper
        top: 8, // Adjust as needed
        right: 8, // Adjust as needed
        backgroundColor: 'rgba(255, 255, 255, 0.7)', // Semi-transparent white
        paddingVertical: 4, // Smaller padding
        paddingHorizontal: 8, // Smaller padding
        borderRadius: 6,
        zIndex: 1, // Ensure it's above the markdown content
    },
    copyButtonText: {
        fontSize: 18, // Adjust icon size
        color: '#2c3e50', // Match code block text color
    },
    copiedText: { // Style for the "Copied!" text
        fontSize: 12, // Smaller text for "Copied!"
        color: '#28a745', // Green color for success
    },
    // Modal Header Styles
    modalOverlay: { // New style for the semi-transparent background
        flex: 1,
        backgroundColor: 'rgba(0, 0, 0, 0.5)', // Semi-transparent black
        justifyContent: 'center', // Center the inner container vertically
        alignItems: 'center', // Center the inner container horizontally
        padding: 20, // Add padding so modal doesn't touch edges
    },
    modalInnerContainer: { // New style for the content box
        width: '95%', // Adjusted width closer to 4/5 feel
        maxWidth: 1800, // Example max width
        height: '90%', // Adjusted height to 4/5 (80%)
        maxHeight: 1800, // Example max height
        backgroundColor: 'white',
        borderRadius: 10,
        overflow: 'hidden', // Keep content within rounded corners
        elevation: 5, // Android shadow
        shadowColor: '#000', // iOS shadow
        shadowOffset: { width: 0, height: 4 },
        shadowOpacity: 0.25,
        shadowRadius: 3.84,
    },
    modalHeader: {
        // paddingTop: Platform.OS === 'ios' ? 40 : 15, // No longer needed with centered modal
        paddingBottom: 10,
        paddingHorizontal: 15,
        backgroundColor: '#f8f9fa', // Light background for header
        borderBottomWidth: 1,
        borderBottomColor: '#e0e7f1',
        alignItems: 'flex-end', // Position button to the right
    },
    modalCloseButton: {
        padding: 5, // Tappable area
    },
    modalCloseButtonText: {
        fontSize: 24,
        fontWeight: 'bold',
        color: '#6c757d', // Muted color
    },
    modalScrollView: {
        // padding: 20, // Padding is now on modalOverlay and modalInnerContainer
        paddingHorizontal: 20, // Keep horizontal padding for content
    }
});

// --- Basic Markdown Styles ---
const markdownStyles = StyleSheet.create({
  // General Text
  body: {
    fontSize: 15.5, // Slightly larger base font
    lineHeight: 24, // Increased line height for readability
    color: '#34495e', // Dark grayish-blue for body text
  },
  // Headings
  heading1: {
    fontSize: 24,
    fontWeight: 'bold',
    marginTop: 20, // More space above H1
    marginBottom: 10,
    borderBottomWidth: 1,
    borderBottomColor: '#e0e7f1', // Lighter border
    paddingBottom: 5,
    color: '#1A2E4C', // Dark blue heading
  },
  heading2: {
    fontSize: 20,
    fontWeight: '600',
    marginTop: 18, // More space above H2
    marginBottom: 8,
    color: '#1A2E4C', // Dark blue heading
  },
  heading3: {
    fontSize: 18,
    fontWeight: '600',
    marginTop: 15, // More space above H3
    marginBottom: 6,
    color: '#2c3e50', // Slightly lighter dark blue
  },
  // Code Blocks (```code```)
  code_block: { // Style for ```code``` blocks
    backgroundColor: '#ecf0f1', // Light gray background
    padding: 12,
    borderRadius: 6, // Slightly more rounded
    marginVertical: 10,
    fontFamily: Platform.OS === 'ios' ? 'Menlo' : 'monospace', // Monospace font
    fontSize: 13,
    color: '#2c3e50', // Darker text for code
  },
  fence: { // Alias for code_block often used
    backgroundColor: '#ecf0f1',
    padding: 12,
    borderRadius: 6,
    marginVertical: 10,
    fontFamily: Platform.OS === 'ios' ? 'Menlo' : 'monospace',
    fontSize: 13,
    color: '#2c3e50',
  },
  // Lists
  bullet_list: {
    marginBottom: 12,
    marginLeft: 10, // Indent list slightly
  },
  ordered_list: {
    marginBottom: 12,
    marginLeft: 10, // Indent list slightly
  },
  list_item: {
    marginBottom: 8,
    flexDirection: 'row', // Needed for proper bullet/number alignment
    alignItems: 'flex-start',
    // You might need custom renderers for advanced bullet/number styling
  },
  // Links
  link: {
    color: '#3498db', // Brighter blue for links
    textDecorationLine: 'underline',
    fontWeight: '500', // Slightly bolder links
  },
  // Emphasis
  strong: {
    fontWeight: 'bold',
    color: '#2c3e50', // Darker bold text
  },
  em: {
    fontStyle: 'italic',
  },
  hr: { // Horizontal rule
    backgroundColor: '#ccc',
    height: 0.5, // Thinner rule
    marginVertical: 20, // More space around rule
    opacity: 0.5, // Make it less prominent
  },
});


export default SetupScreen;
