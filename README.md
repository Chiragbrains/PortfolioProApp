# Setting Up Your Supabase Project for the Portfolio Pro App

**Welcome & How It Works**

Welcome to the Portfolio Pro Tracker! This application is designed to help you monitor your stock and ETF investments directly from your device (web or mobile).

*   **Your Data, Your Database:** Unlike many apps, this one connects *directly* to **your own private Supabase project**. Supabase provides a standard, secure PostgreSQL database that you control.
*   **No App Hosting Needed:** You **do not** need to host the application code itself. You only need to set up the free Supabase database by following the steps below. The app runs locally in your browser or on your device.
*   **Privacy Focused:** Your portfolio data and Supabase credentials (URL, Anon Key) are stored locally on your device/browser and are **never** sent to any central server managed by the app developer.

**High-Level Features:**

*   Track stock, ETF, and cash positions across multiple accounts.
*   View consolidated portfolio summaries and performance (P&L, percentages).
*   Group and view holdings by brokerage account.
*   Visualize your portfolio's value over time with a history chart.
*   Import your holdings easily from an Excel file.
*   Automatic background data refresh (via your Supabase Edge Function and Cron Job).
 
**Important Note on Data Refresh:** This application is designed to be efficient. It will only attempt to fetch fresh stock prices from Yahoo Finance via the Edge Function if the last data refresh (recorded in your `portfolio_history` table) was more than 2 hours ago. Otherwise, it will use the most recently cached prices stored in your `portfolio_summary` table. The scheduled task (Cron Job) in Step 5 ensures this data is updated automatically in the background, even when you are not using the app.

---

## Setup Guide

Follow these steps carefully to create and configure your own Supabase database.

**Estimated Time:** 15-20 minutes

**Prerequisites:** A Supabase account (free tier is sufficient). Sign up at supabase.com.

---

### Step 1: Create a New Supabase Project

1.  Log in to your Supabase account.
2.  Click on "**New project**".
3.  Choose an organization.
4.  Enter a **Project Name** (e.g., "My Portfolio Pro").
5.  Generate or enter a secure **Database Password** (save this somewhere safe, though the app won't need it directly).
6.  Select a **Region** closest to you.
7.  Choose the **Free Plan**.
8.  Click "**Create new project**" and wait for it to be set up.

---

### Step 2: Create Required Database Tables & RPC Function

You need to create three tables (`investment_accounts`, `portfolio_summary`, `portfolio_history`) and a helper function in your Supabase PostgreSQL database.

1.  Once your project is ready, navigate to the **SQL Editor** in the left sidebar.
2.  Click "**New query**".
3.  Copy the entire SQL code block below, paste it into the query editor, and click "**RUN**".

    ```sql
    -- 1. Create the 'investment_accounts' table to hold your portfolio positions
    -- Renamed to 'investment_accounts' to store individual transactions
    CREATE TABLE public.investment_accounts (
      id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
      created_at timestamp with time zone DEFAULT now() NOT NULL,
      ticker text NOT NULL,
      account text NOT NULL,
      quantity numeric NOT NULL,
      cost_basis numeric NOT NULL,
    );

    -- Add comments for clarity (optional)
    COMMENT ON TABLE public.investment_accounts IS 'Stores individual buy/sell transactions for all accounts.';

    -- Note: A unique constraint on (ticker, account) might not be suitable for a transaction table.
    -- Remove or adjust if multiple transactions for the same ticker/account are expected.
    -- ALTER TABLE public.investment_accounts
    --   ADD CONSTRAINT investment_accounts_ticker_account_unique UNIQUE (ticker, account);

    -- 2. Create the 'portfolio_summary' table to store aggregated positions and cached prices
    -- Replaces the old 'stock_cache' and provides a summarized view instead of just prices
    CREATE TABLE public.portfolio_summary (
      ticker text PRIMARY KEY, -- Unique identifier for the stock/asset
      company_name text, -- Name of the company/asset
      total_quantity numeric,
      average_cost_basis numeric,
      current_price numeric,
      total_cost_basis_value numeric, -- Total cost basis (avg_cost * quantity)
      market_value numeric,
      pnl_dollar numeric, -- Profit/Loss in currency
      pnl_percent numeric, -- Profit/Loss in percentage
      portfolio_percent numeric, -- Percentage of the total portfolio value
      type text, -- Type of asset (e.g., 'stock', 'etf', 'cash')
      last_updated timestamp with time zone -- When the price/data was last updated
    );
    COMMENT ON TABLE public.portfolio_summary IS 'Aggregated view of holdings per ticker, including cached prices and performance metrics.';

    -- 3. Create the 'portfolio_history' table for daily snapshots
    CREATE TABLE public.portfolio_history (
      id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
      date date NOT NULL,
      total_value numeric, -- Represents total portfolio value (adjust based on Edge Function logic)
      total_cost_basis numeric, -- Represents total cost basis (adjust based on Edge Function logic)
      total_pnl numeric, -- Represents overall P&L (adjust based on Edge Function logic)
      cash_value numeric, -- Stores the cash value separately if applicable
      created_at timestamp with time zone DEFAULT now() NOT NULL -- Tracks when the snapshot was last updated/created
    );

    -- Add a unique constraint on the date column for daily upserts
    ALTER TABLE public.portfolio_history
      ADD CONSTRAINT portfolio_history_date_unique UNIQUE (date);

    -- 4. Create the truncate_investment_accounts function needed by the app
    -- This allows truncating the table via RPC without granting full DELETE privileges
    CREATE OR REPLACE FUNCTION truncate_investment_accounts()
    RETURNS void AS $$
    BEGIN
      TRUNCATE TABLE investment_accounts RESTART IDENTITY CASCADE;
    END;
    $$ LANGUAGE plpgsql SECURITY DEFINER;

4.  Verify that the query ran successfully and the three tables (`investment_accounts`, `portfolio_summary`, `portfolio_history`) appear in the **Table Editor**.

---

### Step 3: Enable Row Level Security (RLS) and Create Policies

RLS protects your data. These policies allow the app (using your public `anon` key) to access the data it needs.

1.  In the left sidebar, navigate to the **SQL Editor**.
2.  Click "**New query**".
3.  Copy the entire SQL code block below, paste it into the query editor, and click "**RUN**".

    ```sql
    -- Enable RLS for each table
    ALTER TABLE public.investment_accounts ENABLE ROW LEVEL SECURITY;
    ALTER TABLE public.portfolio_summary ENABLE ROW LEVEL SECURITY;
    ALTER TABLE public.portfolio_history ENABLE ROW LEVEL SECURITY;

    -- Grant permissions to the 'anon' role (used by the app)
    -- Note: 'public' role implicitly includes 'anon'

    -- Policies for 'investment_accounts' table (Allow all actions for simplicity - REVIEW THIS)
    -- Consider if more restrictive policies are needed (e.g., based on user ID if you add authentication)
    CREATE POLICY "Allow ALL access on investment_accounts"
      ON public.investment_accounts
      FOR ALL -- Covers SELECT, INSERT, UPDATE, DELETE
      USING (true) -- Allows the action if this condition is true
      WITH CHECK (true); -- Enforces this condition on INSERT/UPDATE

    -- Policies for 'portfolio_summary' table (Allow read, insert, update)
    CREATE POLICY "Allow read access on portfolio_summary"
      ON public.portfolio_summary
      FOR SELECT
      USING (true);

    CREATE POLICY "Allow insert/update access on portfolio_summary"
      ON public.portfolio_summary
      FOR ALL -- Covers INSERT, UPDATE (needed for upsert)
      USING (true)
      WITH CHECK (true);

    -- Policies for 'portfolio_history' table (Allow read, insert, update)
    CREATE POLICY "Allow read access on portfolio_history"
      ON public.portfolio_history
      FOR SELECT
      USING (true);

    CREATE POLICY "Allow insert/update access on portfolio_history"
      ON public.portfolio_history
      FOR ALL -- Covers INSERT, UPDATE (needed for upsert)
      USING (true)
      WITH CHECK (true);

    -- Grant usage on schema and sequences if needed (often default, but good practice)
    GRANT USAGE ON SCHEMA public TO anon;
    GRANT ALL ON ALL TABLES IN SCHEMA public TO anon;
    GRANT ALL ON ALL SEQUENCES IN SCHEMA public TO anon;
    GRANT ALL ON ALL FUNCTIONS IN SCHEMA public TO anon; -- If using RPC functions accessible by anon
    ```

4.  Verify that the query ran successfully. You can double-check in **Authentication** -> **Policies** that RLS is enabled for the tables and policies exist.

---

### Step 4: Create the Supabase Edge Function

This function runs on Supabase servers to fetch live stock prices and update your cache and history.

1.  In the left sidebar, navigate to **Edge Functions**.
2.  Click "**Deploy a new function**" - via Editor
3.  Enter the **Function name**: `portfolio-processor` (use this exact name) at bottom right.
4.  You'll be shown an editor with default code. **Delete all the default code**.
5.  **Copy the entire Edge Function code provided below** and paste it into the editor:

    ```typescript
    // --- PASTE YOUR EDGE FUNCTION CODE HERE ---
    import { serve } from 'https://deno.land/std@0.177.0/http/server.ts';
    import { createClient } from 'https://esm.sh/@supabase/supabase-js@2'; // Added SupabaseClient type
    import { corsHeaders } from '../_shared/cors.ts';
    // --- Configuration ---
    const YAHOO_FINANCE_API_BASE = 'https://query1.finance.yahoo.com/v8/finance/chart/';
    const CACHE_FRESHNESS_HOURS = 2;
    const USER_AGENT = 'MyStockPortfolioApp/1.0 (Supabase Edge Function)';
    // --- Helper Functions (Keep exactly as they were) ---
    function mapInstrumentType(instrumentType) {
      if (!instrumentType) return null;
      const lowerType = instrumentType.toLowerCase();
      if (lowerType === 'equity') return 'stock';
      if (lowerType === 'etf' || lowerType === 'mutualfund') return 'etf';
      // Add 'cash' mapping if needed, though usually handled separately
      // if (lowerType === 'cash') return 'cash';
      return null;
    }
    async function updateStockCache(supabaseClient, ticker, currentPrice, companyName, type) {
      try {
        const utcTimestamp = new Date().toISOString();
        const { error } = await supabaseClient.from('stock_cache').upsert({
          ticker,
          current_price: currentPrice,
          company_name: companyName,
          type: type,
          last_refreshed: utcTimestamp
        }, {
          onConflict: 'ticker'
        });
        if (error) console.error(`Cache update error for ${ticker}:`, error.message);
        else console.log(`Cache updated for ${ticker}`);
      } catch (error) {
        console.error(`Cache update exception for ${ticker}:`, error.message);
      }
    }
    async function fetchFromCache(supabaseClient, ticker, ignoreAge = false) {
      const defaultReturn = {
        price: null,
        name: null,
        type: null,
        last_refreshed: null
      };
      try {
        const { data, error } = await supabaseClient.from('stock_cache').select('current_price, company_name, type, last_refreshed').eq('ticker', ticker).maybeSingle();
        if (error) {
          console.error(`Cache fetch error for ${ticker}:`, error.message);
          return defaultReturn;
        }
        if (data?.current_price !== null && data?.last_refreshed) {
          const cacheTime = new Date(data.last_refreshed);
          const currentTime = new Date();
          const cacheAgeHours = (currentTime.getTime() - cacheTime.getTime()) / (1000 * 60 * 60);
          if (ignoreAge || cacheAgeHours < CACHE_FRESHNESS_HOURS) {
            const reason = ignoreAge ? 'ignoring age' : `fresh (${cacheAgeHours.toFixed(2)} hrs old)`;
            console.log(`Using cached data for ${ticker} (${reason})`);
            return {
              price: data.current_price,
              name: data.company_name,
              type: data.type,
              last_refreshed: data.last_refreshed
            };
          } else {
            console.log(`Cache for ${ticker} outdated (${cacheAgeHours.toFixed(2)} hrs old).`);
            // Return stale meta even if price is outdated
            return {
              price: null,
              name: data.company_name,
              type: data.type,
              last_refreshed: data.last_refreshed
            };
          }
        }
        return defaultReturn;
      } catch (cacheError) {
        console.error(`Cache fetch exception for ${ticker}:`, cacheError.message);
        return defaultReturn;
      }
    }
    async function fetchCurrentPriceAndMeta(supabaseClient, ticker) {
      // Try fresh cache first
      let cachedData = await fetchFromCache(supabaseClient, ticker, false);
      if (cachedData.price !== null) {
        return {
          price: cachedData.price,
          name: cachedData.name,
          type: cachedData.type
        };
      }
      // Price not fresh or not found, try fetching from Yahoo
      let fetchedPrice = null;
      let fetchedName = cachedData.name; // Keep stale name as fallback
      let fetchedType = cachedData.type; // Keep stale type as fallback
      let nameFromYahoo = null;
      let typeFromYahoo = null;
      try {
        const url = `${YAHOO_FINANCE_API_BASE}${ticker}`;
        console.log(`Fetching URL: ${url}`);
        const response = await fetch(url, {
          headers: {
            'User-Agent': USER_AGENT
          }
        });
        if (response.ok) {
          const data = await response.json();
          const meta = data?.chart?.result?.[0]?.meta;
          // Extract Name
          if (meta?.shortName) nameFromYahoo = meta.shortName;
          else if (meta?.longName) nameFromYahoo = meta.longName;
          if (nameFromYahoo !== null) fetchedName = nameFromYahoo; // Prefer Yahoo name
          // Extract Type
          if (meta?.instrumentType) typeFromYahoo = mapInstrumentType(meta.instrumentType);
          if (typeFromYahoo !== null) fetchedType = typeFromYahoo; // Prefer Yahoo type
          // Extract Price (prefer regularMarketPrice, fallback to close)
          const regularMarketPrice = meta?.regularMarketPrice;
          const closePriceArray = data?.chart?.result?.[0]?.indicators?.quote?.[0]?.close;
          const lastClosePrice = closePriceArray?.[closePriceArray.length - 1]; // Get the last available close price
          if (typeof regularMarketPrice === 'number' && regularMarketPrice > 0) {
            fetchedPrice = regularMarketPrice;
          } else if (typeof lastClosePrice === 'number' && lastClosePrice > 0) {
            fetchedPrice = lastClosePrice;
            console.log(`Using last close price for ${ticker}: ${fetchedPrice}`);
          }
          if (fetchedPrice !== null) {
            console.log(`Fetched from Yahoo for ${ticker}: Price=$${fetchedPrice}, Name=${fetchedName}, Type=${fetchedType}`);
            // Update cache with fresh data
            await updateStockCache(supabaseClient, ticker, fetchedPrice, fetchedName, fetchedType);
            return {
              price: fetchedPrice,
              name: fetchedName,
              type: fetchedType
            };
          } else {
            console.warn(`No valid price found for ${ticker} in Yahoo response.`);
          }
        } else {
          console.error(`Yahoo fetch error for ${ticker}: ${response.status} ${response.statusText}`);
        }
      } catch (error) {
        console.error(`Yahoo fetch/processing error for ${ticker}:`, error);
      }
      // If Yahoo fetch failed or returned no price, try using stale cache price
      if (fetchedPrice === null) {
        console.log(`Yahoo fetch failed for ${ticker}. Trying stale cache price.`);
        cachedData = await fetchFromCache(supabaseClient, ticker, true); // Ignore age
        if (cachedData.price !== null) {
          // Use the name/type determined during the Yahoo attempt (which might be stale or from Yahoo)
          console.log(`Using stale cache price for ${ticker}: ${cachedData.price}, Name: ${fetchedName}, Type: ${fetchedType}`);
          // Update cache with stale price but potentially updated meta
          await updateStockCache(supabaseClient, ticker, cachedData.price, fetchedName, fetchedType);
          return {
            price: cachedData.price,
            name: fetchedName,
            type: fetchedType
          };
        }
      }
      // Absolute fallback if no price could be determined
      console.error(`Could not determine price for ${ticker}. Returning null price.`);
      return {
        price: null,
        name: fetchedName,
        type: fetchedType
      }; // Return potentially stale meta even if price is null
    }
    // --- End Helper Functions ---
    // --- Main Request Handler ---
    serve(async (req)=>{
      // Handle CORS preflight request
      if (req.method === 'OPTIONS') {
        return new Response('ok', {
          headers: corsHeaders
        });
      }
      try {
        // --- Initialize Supabase Client ---
        const supabaseUrl = Deno.env.get('SUPABASE_URL');
        const supabaseServiceKey = Deno.env.get('SUPABASE_SERVICE_ROLE_KEY'); // Use the SERVICE ROLE KEY
        if (!supabaseUrl || !supabaseServiceKey) {
          throw new Error('Missing Supabase environment variables.');
        }
        // Use service role key for admin-level access needed for updates/deletes
        const supabaseClient = createClient(supabaseUrl, supabaseServiceKey, {
          auth: {
            // Required for service role key
            persistSession: false,
            autoRefreshToken: false,
            detectSessionInUrl: false
          }
        });
        // --- 1. Fetch all transactions from investment_accounts ---
        console.log("Fetching transactions from investment_accounts...");
        const { data: transactions, error: fetchError } = await supabaseClient.from('investment_accounts').select('id, ticker, account, quantity, cost_basis, created_at'); // Select necessary fields
        if (fetchError) {
          throw new Error(`Failed to fetch investment accounts: ${fetchError.message}`);
        }
        const currentTimestamp = new Date().toISOString();
        let overallMarketValue = 0;
        let overallCostBasisValue = 0;
        let overallCashValue = 0;
        let tickerSummaries = []; // Define outside the conditional blocks
        // --- 2. Handle Empty Transactions (Clear All Scenario) ---
        if (!transactions || transactions.length === 0) {
          console.log("No investment transactions found. Zeroing out portfolio_summary.");
          // Fetch existing tickers from portfolio_summary to preserve them
          const { data: existingSummaries, error: fetchExistingError } = await supabaseClient.from('portfolio_summary').select('ticker, company_name, current_price, type'); // Select fields to keep
          if (fetchExistingError) {
            console.error("Error fetching existing summary tickers:", fetchExistingError);
            // Decide if you want to throw or continue (maybe log and proceed with empty history)
            throw new Error(`Failed to fetch existing summaries: ${fetchExistingError.message}`);
          }
          if (existingSummaries && existingSummaries.length > 0) {
            // Prepare updates to zero out financial fields
            const zeroedSummaries = existingSummaries.map((existing)=>({
                ticker: existing.ticker,
                company_name: existing.company_name,
                total_quantity: 0,
                average_cost_basis: 0,
                current_price: existing.current_price,
                total_cost_basis_value: 0,
                market_value: 0,
                pnl_dollar: 0,
                pnl_percent: 0,
                portfolio_percent: 0,
                type: existing.type,
                last_updated: currentTimestamp
              }));
            // Upsert the zeroed-out summaries
            console.log(`Upserting ${zeroedSummaries.length} zeroed summary rows...`);
            const { error: upsertError } = await supabaseClient.from('portfolio_summary').upsert(zeroedSummaries, {
              onConflict: 'ticker'
            });
            if (upsertError) {
              console.error("Error upserting zeroed summaries:", upsertError);
            // Log error but continue to update history
            } else {
              console.log("Successfully zeroed out summary rows.");
            }
          } else {
            console.log("No existing summaries found to zero out.");
          }
        // Note: overallMarketValue, overallCostBasisValue, overallCashValue remain 0
        } else {
          // --- 3. Process Non-Empty Transactions (Existing Logic) ---
          console.log(`Fetched ${transactions.length} transactions. Processing...`);
          // --- 3a. Consolidate transactions by ticker ---
          console.log("Consolidating transactions by ticker...");
          const consolidatedMap = new Map();
          for (const tx of transactions){
            const ticker = tx.ticker?.toUpperCase() ?? 'UNKNOWN';
            const quantity = tx.quantity ?? 0;
            const costBasis = tx.cost_basis ?? 0;
            const existing = consolidatedMap.get(ticker) ?? {
              totalQuantity: 0,
              totalCostValue: 0
            };
            existing.totalQuantity += quantity;
            // Only add cost for positive quantity (buys/adds)
            if (quantity > 0) {
              existing.totalCostValue += quantity * costBasis;
            }
            // Note: Simple weighted average cost. Sells require more complex logic (FIFO/LIFO etc.)
            consolidatedMap.set(ticker, existing);
          }
          console.log(`Consolidated into ${consolidatedMap.size} unique tickers.`);
          // --- 3b. Fetch prices/meta and calculate initial summary ---
          console.log("Fetching prices and calculating summaries...");
          for (const [ticker, consolidated] of consolidatedMap.entries()){
            const { totalQuantity, totalCostValue } = consolidated;
            // Skip tickers with zero or negative quantity after consolidation
            if (totalQuantity <= 0) {
              console.log(`Skipping ticker ${ticker} due to zero or negative quantity (${totalQuantity}).`);
              continue; // Skip to next ticker
            }
            let metaResult;
            let finalType;
            if (ticker === 'CASH') {
              metaResult = {
                price: 1.0,
                name: 'Cash',
                type: null
              };
              finalType = 'cash';
              overallCashValue += totalQuantity; // Accumulate cash value
            } else {
              metaResult = await fetchCurrentPriceAndMeta(supabaseClient, ticker);
              finalType = metaResult.type; // Use type determined from Yahoo/cache
            }
            const currentPrice = metaResult.price;
            const marketValue = currentPrice !== null ? currentPrice * totalQuantity : 0;
            const averageCostBasis = totalQuantity > 0 ? totalCostValue / totalQuantity : 0; // Weighted average cost
            const pnlDollar = marketValue - totalCostValue;
            const pnlPercent = totalCostValue > 0 ? pnlDollar / totalCostValue * 100 : 0;
            tickerSummaries.push({
              ticker: ticker,
              company_name: metaResult.name,
              total_quantity: totalQuantity,
              average_cost_basis: averageCostBasis,
              current_price: currentPrice,
              total_cost_basis_value: totalCostValue,
              market_value: marketValue,
              pnl_dollar: pnlDollar,
              pnl_percent: pnlPercent,
              portfolio_percent: 0,
              type: finalType,
              last_updated: currentTimestamp
            });
            overallMarketValue += marketValue; // Accumulate total market value
            overallCostBasisValue += totalCostValue; // Accumulate total cost basis
          }
          console.log("Finished initial summary calculations.");
          // --- 3c. Calculate portfolio percentage ---
          console.log("Calculating portfolio percentages...");
          tickerSummaries.forEach((summary)=>{
            summary.portfolio_percent = overallMarketValue > 0 ? summary.market_value / overallMarketValue * 100 : 0;
          });
          // --- 3d. Upsert summaries into portfolio_summary table ---
          console.log(`Upserting ${tickerSummaries.length} rows into portfolio_summary...`);
          // Delete tickers from summary table that are no longer present (have zero quantity)
          const currentTickers = tickerSummaries.map((s)=>s.ticker);
          if (currentTickers.length > 0) {
            const { error: deleteError } = await supabaseClient.from('portfolio_summary').delete().not('ticker', 'in', `(${currentTickers.map((t)=>`'${t}'`).join(',')})`); // Delete where ticker NOT IN current list
            if (deleteError) {
              console.error("Error deleting old summary rows:", deleteError);
            // Log error but continue
            } else {
              console.log("Deleted obsolete summary rows (if any).");
            }
          } else {
            // If no current tickers with positive quantity, delete all summary rows (shouldn't happen if CASH exists)
            console.warn("No tickers with positive quantity found after consolidation. Deleting all summary rows.");
            const { error: deleteAllError } = await supabaseClient.from('portfolio_summary').delete().neq('ticker', 'DUMMY_VALUE_TO_DELETE_ALL'); // Delete all
            if (deleteAllError) {
              console.error("Error deleting all summary rows:", deleteAllError);
            }
          }
          // Upsert the current summaries
          if (tickerSummaries.length > 0) {
            const { data: summaryUpsertData, error: summaryUpsertError } = await supabaseClient.from('portfolio_summary').upsert(tickerSummaries, {
              onConflict: 'ticker'
            }).select('ticker'); // Select only ticker for brevity
            if (summaryUpsertError) {
              throw new Error(`Failed to save portfolio summary: ${summaryUpsertError.message}`);
            }
            console.log(`Successfully upserted ${summaryUpsertData?.length ?? 0} rows into portfolio_summary.`);
          } else {
            console.log("No valid ticker summaries to upsert.");
          }
        } // End of else block (processing non-empty transactions)
        // --- 4. Update portfolio_history table (Always runs, uses calculated totals) ---
        const overallPnl = overallMarketValue - overallCostBasisValue;
        const historySnapshotData = {
          date: currentTimestamp.split('T')[0],
          total_value: overallMarketValue,
          total_cost_basis: overallCostBasisValue,
          total_pnl: overallPnl,
          cash_value: overallCashValue,
          created_at: currentTimestamp
        };
        console.log('Upserting portfolio_history snapshot:', JSON.stringify(historySnapshotData));
        const { error: historyUpsertError } = await supabaseClient.from('portfolio_history').upsert(historySnapshotData, {
          onConflict: 'date'
        }); // Upsert based on date
        if (historyUpsertError) {
          // Warn instead of throwing, as history update is secondary
          console.warn(`Failed to save portfolio history snapshot: ${historyUpsertError.message}`);
        } else {
          console.log("Successfully upserted portfolio_history snapshot.");
        }
        // --- 5. Return success response ---
        return new Response(JSON.stringify({
          success: true,
          summaryCount: tickerSummaries.length,
          message: transactions && transactions.length > 0 ? 'Portfolio processed.' : 'Portfolio zeroed out.'
        }), {
          headers: {
            ...corsHeaders,
            'Content-Type': 'application/json'
          },
          status: 200
        });
      } catch (error) {
        // Catch any errors from the main try block
        console.error('Error in Edge Function:', error);
        return new Response(JSON.stringify({
          error: error.message
        }), {
          headers: {
            ...corsHeaders,
            'Content-Type': 'application/json'
          },
          status: 500
        });
      }
    });
    // --- END OF EDGE FUNCTION CODE ---
    ```

7.  Click "**Save and Deploy**" (or Deploy). Wait for the deployment to complete.
8.  **Set Environment Variables:**
    *   Go to **Project Settings** -> **Edge Functions**.
    *   Add below **Edge Function Secrets**.
    *   Add `SUPABASE_URL`: Find this in **Project Settings** -> **API** -> **Project URL**.
    *   Add `SUPABASE_SERVICE_ROLE_KEY`: Find this in **Project Settings** -> **API** -> **Project API keys** -> `service_role` key (**Keep this secret!**).
    *   Click "**Save**".

---

### Step 5: Schedule the Edge Function (Cron Job via Dashboard)

This automatically runs your Edge Function (e.g., daily or every few hours) **to keep price data fresh and build the data needed for the history chart, even when you are not using the application.**

1.  In the left sidebar, navigate to **Database** -> **Functions**.
2.  Click "**New cron job**". - go here if you can't find (https://supabase.com/dashboard/project/vdxrsbzfqucnlfxlkhdu/integrations/cron/jobs)
3.  Fill in the details:
    *   **Name:** Enter a descriptive name, e.g., `invoke-portfolio-processor`.
    *   **Schedule:** Enter your desired schedule using standard cron syntax.
        *   Example: `0 */4 * * *` (Runs every 4 hours at the start of the hour).
        *   Example: `0 2 * * *` (Runs once a day at 2 AM UTC).
        *   Use natural language or crontab.guru to help build your schedule. Be mindful of free tier invocation limits.
    *   **Function Hook:** Select `HTTP Request`.
    *   **Method:** Select `POST`.
    *   **URL:** Enter your Edge Function URL:
        *   Format: `[YOUR SUPABASE PROJECT URL]/functions/v1/portfolio-processor`
        *   Replace `[YOUR SUPABASE PROJECT URL]` with your actual Project URL (from Step 4 or Step 6).
    *   **Headers:**
        *   Click "**Add Header**".
        *   **Name:** `Authorization`
        *   **Value:** `Bearer [YOUR SUPABASE SERVICE ROLE KEY]`
        *   Replace `[YOUR SUPABASE SERVICE ROLE KEY]` with your actual `service_role` key (from Step 4 or Step 6). **Keep this key secure.**
    *   **Body:** Leave this as the default empty JSON object `{}` unless your function specifically requires a body.
4.  Review the details carefully.
5.  Click "**Create cron job**".

---

### Step 6: Find Your Project URL and Anon Key

The application needs these to connect to *your* Supabase project.

1.  In the left sidebar, go to **Project Settings** (the gear icon).
2.  Select **API**.
3.  Under **Project API keys**:
    *   Copy the **URL**. This is your Supabase Project URL.
    *   Copy the **`anon` `public`** key. This is your Supabase Anon Key.
    *   Save in browser for easy access
4.  Keep these copied values ready for the next step. **Do not use the `service_role` key in the app.**

---

### Step 7: Enter Credentials in the Portfolio Pro App

1.  Open the Portfolio Pro App.
2.  You should see a setup screen asking for your Supabase details.
3.  Carefully paste the **Project URL** you copied into the "Supabase Project URL" field.
4.  Carefully paste the **Anon Key** you copied into the "Supabase Anon Key" field.
5.  Click "**Connect & Save**".

---

**Setup Complete!**

If the connection is successful, the app should load and function using your own Supabase database. If you encounter errors, double-check that you copied the URL and Anon Key correctly and that all tables, RLS policies, and the Edge Function were set up exactly as described. Check the Edge Function logs and Cron Job history in your Supabase dashboard for troubleshooting.
