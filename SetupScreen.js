// /SetupScreen.js (New File)
import React, { useState } from 'react';
import { View, Text, TextInput, Button, StyleSheet, ActivityIndicator, Alert, ScrollView, Linking, TouchableOpacity, Modal, Platform, Clipboard } from 'react-native'; // Added Clipboard
import { useSupabaseConfig } from './SupabaseConfigContext';
import Markdown from 'react-native-markdown-display';
// Removed: import * as FileSystem from 'expo-file-system';
// Removed: import { Platform } from 'react-native'; // No longer needed for this

// --- Bundled README Content ---
// Removed the import: import readmeContentRaw from './README.md';

// Paste the full content of your README.md file here inside the backticks:
// --- Split Markdown Content ---
// We'll split the content around the collapsible blocks

const readmeContent = `# Portfolio Pro - Quick Start Guide

Welcome to Portfolio Pro! This app helps you track your stock and ETF investments easily. Here's how to get started in just a few simple steps.

## What You'll Need
- A free Supabase account (we'll help you create one)
- About 5 minutes of your time

## Step 1: Create Your Free Database
1. Go to [supabase.com](https://supabase.com) and sign up for a free account
2. Click "New Project"
3. Name your project (e.g., "My Portfolio")
4. Create a password (save it somewhere safe)
5. Choose a region close to you
6. Click "Create new project"

## Step 2: Get Your Connection Details
1. Once your project is created, click the gear icon (⚙️) in the left sidebar
2. Click "API" in the settings menu
3. You'll see two important pieces of information:
   - Project URL (looks like: \`https://xxxxxxxxxxxx.supabase.co\`)
   - \`anon\` public key (a long string starting with \`eyJ...\`)
4. Keep this page open - you'll need these details in a moment

## Step 3: Set Up Your Database
1. Click "SQL Editor" in the left sidebar
2. Click "New Query"
3. Copy and paste this code:
\`\`\`sql
-- Enable the pgvector extension
CREATE EXTENSION IF NOT EXISTS vector;

-- Create tables for your portfolio
CREATE TABLE public.investment_accounts (
  id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  created_at timestamp with time zone DEFAULT now() NOT NULL,
  ticker text NOT NULL,
  account text NOT NULL,
  quantity numeric NOT NULL,
  cost_basis numeric NOT NULL
);

CREATE TABLE public.portfolio_summary (
  ticker text PRIMARY KEY,
  company_name text,
  total_quantity numeric,
  average_cost_basis numeric,
  current_price numeric,
  total_cost_basis_value numeric,
  market_value numeric,
  pnl_dollar numeric,
  pnl_percent numeric,
  portfolio_percent numeric,
  type text,
  last_updated timestamp with time zone,
  embedded vector(1536)
);

CREATE TABLE public.portfolio_history (
  id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  date date NOT NULL,
  total_value numeric,
  total_cost_basis numeric,
  total_pnl numeric,
  cash_value numeric,
  created_at timestamp with time zone DEFAULT now() NOT NULL
);

-- Add a unique constraint for daily updates
ALTER TABLE public.portfolio_history
  ADD CONSTRAINT portfolio_history_date_unique UNIQUE (date);

-- Create function to safely truncate investment_accounts table
CREATE OR REPLACE FUNCTION truncate_investment_accounts()
RETURNS void AS $$
BEGIN
  TRUNCATE TABLE investment_accounts RESTART IDENTITY CASCADE;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Create function for vector similarity search in portfolio_summary
CREATE OR REPLACE FUNCTION match_portfolio_summary(
  query_embedding vector(1536),
  match_threshold float,
  match_count int
)
RETURNS TABLE (
  ticker text,
  company_name text,
  total_quantity numeric,
  average_cost_basis numeric,
  current_price numeric,
  market_value numeric,
  pnl_dollar numeric,
  pnl_percent numeric,
  similarity float
)
LANGUAGE plpgsql
AS $$
BEGIN
  RETURN QUERY
  SELECT
    ps.ticker,
    ps.company_name,
    ps.total_quantity,
    ps.average_cost_basis,
    ps.current_price,
    ps.market_value,
    ps.pnl_dollar,
    ps.pnl_percent,
    1 - (ps.embedded <=> query_embedding) AS similarity
  FROM
    portfolio_summary ps
  WHERE 1 - (ps.embedded <=> query_embedding) > match_threshold
  ORDER BY
    ps.embedded <=> query_embedding
  LIMIT match_count;
END;
$$;

-- Create an index for faster similarity search
CREATE INDEX IF NOT EXISTS portfolio_summary_embedding_idx 
ON portfolio_summary 
USING ivfflat (embedded vector_cosine_ops)
WITH (lists = 100);
\`\`\`
4. Click "Run" to create your tables and functions

## Step 4: Set Up Automatic Updates
1. Click "Edge Functions" in the left sidebar
2. Click "Deploy a new function"
3. Name it \`portfolio-processor\`
4. Copy and paste this code:
\`\`\`typescript
import { serve } from 'https://deno.land/std@0.177.0/http/server.ts';
import { createClient } from 'https://esm.sh/@supabase/supabase-js@2';
import { corsHeaders } from '../_shared/cors.ts';

// Configuration
const YAHOO_FINANCE_API_BASE = 'https://query1.finance.yahoo.com/v8/finance/chart/';
const CACHE_FRESHNESS_HOURS = 2;
const USER_AGENT = 'MyStockPortfolioApp/1.0 (Supabase Edge Function)';

// Helper Functions
function mapInstrumentType(instrumentType) {
  if (!instrumentType) return null;
  const lowerType = instrumentType.toLowerCase();
  if (lowerType === 'equity') return 'stock';
  if (lowerType === 'etf' || lowerType === 'mutualfund') return 'etf';
  return null;
}

async function updateStockCache(supabaseClient, ticker, currentPrice, companyName, type) {
  try {
    const utcTimestamp = new Date().toISOString();
    const { error } = await supabaseClient.from('stock_cache').upsert({
      ticker,
      current_price: currentPrice,
      company_name: companyName,
      type: type,
      last_refreshed: utcTimestamp
    }, {
      onConflict: 'ticker'
    });
    if (error) console.error(\`Cache update error for \${ticker}:\`, error.message);
    else console.log(\`Cache updated for \${ticker}\`);
  } catch (error) {
    console.error(\`Cache update exception for \${ticker}:\`, error.message);
  }
}

async function fetchFromCache(supabaseClient, ticker, ignoreAge = false) {
  const defaultReturn = {
    price: null,
    name: null,
    type: null,
    last_refreshed: null
  };
  try {
    const { data, error } = await supabaseClient.from('stock_cache').select('current_price, company_name, type, last_refreshed').eq('ticker', ticker).maybeSingle();
    if (error) {
      console.error(\`Cache fetch error for \${ticker}:\`, error.message);
      return defaultReturn;
    }
    if (data?.current_price !== null && data?.last_refreshed) {
      const cacheTime = new Date(data.last_refreshed);
      const currentTime = new Date();
      const cacheAgeHours = (currentTime.getTime() - cacheTime.getTime()) / (1000 * 60 * 60);
      if (ignoreAge || cacheAgeHours < CACHE_FRESHNESS_HOURS) {
        const reason = ignoreAge ? 'ignoring age' : \`fresh (\${cacheAgeHours.toFixed(2)} hrs old)\`;
        console.log(\`Using cached data for \${ticker} (\${reason})\`);
        return {
          price: data.current_price,
          name: data.company_name,
          type: data.type,
          last_refreshed: data.last_refreshed
        };
      } else {
        console.log(\`Cache for \${ticker} outdated (\${cacheAgeHours.toFixed(2)} hrs old).\`);
        return {
          price: null,
          name: data.company_name,
          type: data.type,
          last_refreshed: data.last_refreshed
        };
      }
    }
    return defaultReturn;
  } catch (cacheError) {
    console.error(\`Cache fetch exception for \${ticker}:\`, cacheError.message);
    return defaultReturn;
  }
}

async function fetchCurrentPriceAndMeta(supabaseClient, ticker) {
  // Try fresh cache first
  let cachedData = await fetchFromCache(supabaseClient, ticker, false);
  if (cachedData.price !== null) {
    return {
      price: cachedData.price,
      name: cachedData.name,
      type: cachedData.type
    };
  }

  // Price not fresh or not found, try fetching from Yahoo
  let fetchedPrice = null;
  let fetchedName = cachedData.name;
  let fetchedType = cachedData.type;
  let nameFromYahoo = null;
  let typeFromYahoo = null;

  try {
    const url = \`\${YAHOO_FINANCE_API_BASE}\${ticker}\`;
    console.log(\`Fetching URL: \${url}\`);
    const response = await fetch(url, {
      headers: {
        'User-Agent': USER_AGENT
      }
    });

    if (response.ok) {
      const data = await response.json();
      const meta = data?.chart?.result?.[0]?.meta;

      // Extract Name
      if (meta?.shortName) nameFromYahoo = meta.shortName;
      else if (meta?.longName) nameFromYahoo = meta.longName;
      if (nameFromYahoo !== null) fetchedName = nameFromYahoo;

      // Extract Type
      if (meta?.instrumentType) typeFromYahoo = mapInstrumentType(meta.instrumentType);
      if (typeFromYahoo !== null) fetchedType = typeFromYahoo;

      // Extract Price
      const regularMarketPrice = meta?.regularMarketPrice;
      const closePriceArray = data?.chart?.result?.[0]?.indicators?.quote?.[0]?.close;
      const lastClosePrice = closePriceArray?.[closePriceArray.length - 1];

      if (typeof regularMarketPrice === 'number' && regularMarketPrice > 0) {
        fetchedPrice = regularMarketPrice;
      } else if (typeof lastClosePrice === 'number' && lastClosePrice > 0) {
        fetchedPrice = lastClosePrice;
        console.log(\`Using last close price for \${ticker}: \${fetchedPrice}\`);
      }

      if (fetchedPrice !== null) {
        console.log(\`Fetched from Yahoo for \${ticker}: Price=\$\${fetchedPrice}, Name=\${fetchedName}, Type=\${fetchedType}\`);
        await updateStockCache(supabaseClient, ticker, fetchedPrice, fetchedName, fetchedType);
        return {
          price: fetchedPrice,
          name: fetchedName,
          type: fetchedType
        };
      } else {
        console.warn(\`No valid price found for \${ticker} in Yahoo response.\`);
      }
    } else {
      console.error(\`Yahoo fetch error for \${ticker}: \${response.status} \${response.statusText}\`);
    }
  } catch (error) {
    console.error(\`Yahoo fetch/processing error for \${ticker}:\`, error);
  }

  // If Yahoo fetch failed, try using stale cache price
  if (fetchedPrice === null) {
    console.log(\`Yahoo fetch failed for \${ticker}. Trying stale cache price.\`);
    cachedData = await fetchFromCache(supabaseClient, ticker, true);
    if (cachedData.price !== null) {
      console.log(\`Using stale cache price for \${ticker}: \${cachedData.price}, Name: \${fetchedName}, Type: \${fetchedType}\`);
      await updateStockCache(supabaseClient, ticker, cachedData.price, fetchedName, fetchedType);
      return {
        price: cachedData.price,
        name: fetchedName,
        type: fetchedType
      };
    }
  }

  // Absolute fallback
  console.error(\`Could not determine price for \${ticker}. Returning null price.\`);
  return {
    price: null,
    name: fetchedName,
    type: fetchedType
  };
}

// Main Request Handler
serve(async (req) => {
  // Handle CORS preflight request
  if (req.method === 'OPTIONS') {
    return new Response('ok', {
      headers: corsHeaders
    });
  }

  try {
    // Initialize Supabase Client
    const supabaseUrl = Deno.env.get('SUPABASE_URL');
    const supabaseServiceKey = Deno.env.get('SUPABASE_SERVICE_ROLE_KEY');
    if (!supabaseUrl || !supabaseServiceKey) {
      throw new Error('Missing Supabase environment variables.');
    }

    const supabaseClient = createClient(supabaseUrl, supabaseServiceKey, {
      auth: {
        persistSession: false,
        autoRefreshToken: false,
        detectSessionInUrl: false
      }
    });

    // Fetch all transactions
    console.log("Fetching transactions from investment_accounts...");
    const { data: transactions, error: fetchError } = await supabaseClient
      .from('investment_accounts')
      .select('id, ticker, account, quantity, cost_basis, created_at');

    if (fetchError) {
      throw new Error(\`Failed to fetch investment accounts: \${fetchError.message}\`);
    }

    const currentTimestamp = new Date().toISOString();
    let overallMarketValue = 0;
    let overallCostBasisValue = 0;
    let overallCashValue = 0;
    let tickerSummaries = [];

    // Handle Empty Transactions
    if (!transactions || transactions.length === 0) {
      console.log("No investment transactions found. Zeroing out portfolio_summary.");
      const { data: existingSummaries, error: fetchExistingError } = await supabaseClient
        .from('portfolio_summary')
        .select('ticker, company_name, current_price, type');

      if (fetchExistingError) {
        console.error("Error fetching existing summary tickers:", fetchExistingError);
        throw new Error(\`Failed to fetch existing summaries: \${fetchExistingError.message}\`);
      }

      if (existingSummaries && existingSummaries.length > 0) {
        const zeroedSummaries = existingSummaries.map((existing) => ({
          ticker: existing.ticker,
          company_name: existing.company_name,
          total_quantity: 0,
          average_cost_basis: 0,
          current_price: existing.current_price,
          total_cost_basis_value: 0,
          market_value: 0,
          pnl_dollar: 0,
          pnl_percent: 0,
          portfolio_percent: 0,
          type: existing.type,
          last_updated: currentTimestamp
        }));

        console.log(\`Upserting \${zeroedSummaries.length} zeroed summary rows...\`);
        const { error: upsertError } = await supabaseClient
          .from('portfolio_summary')
          .upsert(zeroedSummaries, {
            onConflict: 'ticker'
          });

        if (upsertError) {
          console.error("Error upserting zeroed summaries:", upsertError);
        } else {
          console.log("Successfully zeroed out summary rows.");
        }
      } else {
        console.log("No existing summaries found to zero out.");
      }
    } else {
      // Process Non-Empty Transactions
      console.log(\`Fetched \${transactions.length} transactions. Processing...\`);
      
      // Consolidate transactions by ticker
      console.log("Consolidating transactions by ticker...");
      const consolidatedMap = new Map();
      
      for (const tx of transactions) {
        const ticker = tx.ticker?.toUpperCase() ?? 'UNKNOWN';
        const quantity = tx.quantity ?? 0;
        const costBasis = tx.cost_basis ?? 0;
        const existing = consolidatedMap.get(ticker) ?? {
          totalQuantity: 0,
          totalCostValue: 0
        };
        
        existing.totalQuantity += quantity;
        if (quantity > 0) {
          existing.totalCostValue += quantity * costBasis;
        }
        
        consolidatedMap.set(ticker, existing);
      }

      console.log(\`Consolidated into \${consolidatedMap.size} unique tickers.\`);

      // Fetch prices/meta and calculate summary
      console.log("Fetching prices and calculating summaries...");
      
      for (const [ticker, consolidated] of consolidatedMap.entries()) {
        const { totalQuantity, totalCostValue } = consolidated;
        
        if (totalQuantity <= 0) {
          console.log(\`Skipping ticker \${ticker} due to zero or negative quantity (\${totalQuantity}).\`);
          continue;
        }

        let metaResult;
        let finalType;

        if (ticker === 'CASH') {
          metaResult = {
            price: 1.0,
            name: 'Cash',
            type: null
          };
          finalType = 'cash';
          overallCashValue += totalQuantity;
        } else {
          metaResult = await fetchCurrentPriceAndMeta(supabaseClient, ticker);
          finalType = metaResult.type;
        }

        const currentPrice = metaResult.price;
        const marketValue = currentPrice !== null ? currentPrice * totalQuantity : 0;
        const averageCostBasis = totalQuantity > 0 ? totalCostValue / totalQuantity : 0;
        const pnlDollar = marketValue - totalCostValue;
        const pnlPercent = totalCostValue > 0 ? pnlDollar / totalCostValue * 100 : 0;

        tickerSummaries.push({
          ticker: ticker,
          company_name: metaResult.name,
          total_quantity: totalQuantity,
          average_cost_basis: averageCostBasis,
          current_price: currentPrice,
          total_cost_basis_value: totalCostValue,
          market_value: marketValue,
          pnl_dollar: pnlDollar,
          pnl_percent: pnlPercent,
          portfolio_percent: 0,
          type: finalType,
          last_updated: currentTimestamp
        });

        overallMarketValue += marketValue;
        overallCostBasisValue += totalCostValue;
      }

      console.log("Finished initial summary calculations.");

      // Calculate portfolio percentage
      console.log("Calculating portfolio percentages...");
      tickerSummaries.forEach((summary) => {
        summary.portfolio_percent = overallMarketValue > 0 ? summary.market_value / overallMarketValue * 100 : 0;
      });

      // Upsert summaries
      console.log(\`Upserting \${tickerSummaries.length} rows into portfolio_summary...\`);
      
      const currentTickers = tickerSummaries.map((s) => s.ticker);
      
      if (currentTickers.length > 0) {
        const { error: deleteError } = await supabaseClient
          .from('portfolio_summary')
          .delete()
          .not('ticker', 'in', \`(\${currentTickers.map((t) => \`'\${t}'\`).join(',')})\`);

        if (deleteError) {
          console.error("Error deleting old summary rows:", deleteError);
        } else {
          console.log("Deleted obsolete summary rows (if any).");
        }
      } else {
        console.warn("No tickers with positive quantity found after consolidation. Deleting all summary rows.");
        const { error: deleteAllError } = await supabaseClient
          .from('portfolio_summary')
          .delete()
          .neq('ticker', 'DUMMY_VALUE_TO_DELETE_ALL');

        if (deleteAllError) {
          console.error("Error deleting all summary rows:", deleteAllError);
        }
      }

      if (tickerSummaries.length > 0) {
        const { data: summaryUpsertData, error: summaryUpsertError } = await supabaseClient
          .from('portfolio_summary')
          .upsert(tickerSummaries, {
            onConflict: 'ticker'
          })
          .select('ticker');

        if (summaryUpsertError) {
          throw new Error(\`Failed to save portfolio summary: \${summaryUpsertError.message}\`);
        }
        console.log(\`Successfully upserted \${summaryUpsertData?.length ?? 0} rows into portfolio_summary.\`);
      } else {
        console.log("No valid ticker summaries to upsert.");
      }
    }

    // Update portfolio history
    const overallPnl = overallMarketValue - overallCostBasisValue;
    const historySnapshotData = {
      date: currentTimestamp.split('T')[0],
      total_value: overallMarketValue,
      total_cost_basis: overallCostBasisValue,
      total_pnl: overallPnl,
      cash_value: overallCashValue,
      created_at: currentTimestamp
    };

    console.log('Upserting portfolio_history snapshot:', JSON.stringify(historySnapshotData));
    
    const { error: historyUpsertError } = await supabaseClient
      .from('portfolio_history')
      .upsert(historySnapshotData, {
        onConflict: 'date'
      });

    if (historyUpsertError) {
      console.warn(\`Failed to save portfolio history snapshot: \${historyUpsertError.message}\`);
    } else {
      console.log("Successfully upserted portfolio_history snapshot.");
    }

    // Return success response
    return new Response(
      JSON.stringify({
        success: true,
        summaryCount: tickerSummaries.length,
        message: transactions && transactions.length > 0 ? 'Portfolio processed.' : 'Portfolio zeroed out.'
      }),
      {
        headers: {
          ...corsHeaders,
          'Content-Type': 'application/json'
        },
        status: 200
      }
    );
  } catch (error) {
    console.error('Error in Edge Function:', error);
    return new Response(
      JSON.stringify({
        error: error.message
      }),
      {
        headers: {
          ...corsHeaders,
          'Content-Type': 'application/json'
        },
        status: 500
      }
    );
  }
});
\`\`\`
5. Click "Deploy"
6. Go to "Project Settings" → "Edge Functions"
7. Add these secrets:
   - \`SUPABASE_URL\`: Paste your Project URL
   - \`SUPABASE_SERVICE_ROLE_KEY\`: Paste your \`service_role\` key (found in Project Settings → API)

## Step 5: Connect the App
1. Open the Portfolio Pro app
2. Enter your Project URL and \`anon\` public key
3. Click "Connect & Save"

That's it! Your portfolio tracker is ready to use. The app will automatically:
- Track your stock and ETF positions
- Show your portfolio's performance
- Update prices every few hours
- Keep your data private and secure

## Need Help?
If you run into any issues:
1. Make sure you copied the URL and keys correctly
2. Check that all steps were completed
3. Contact support at support@portfoliopro.com

## Privacy Note
Your portfolio data is stored in your own private database. The app never sees or stores your data - it only connects to your database to show you your information.`;

const SetupScreen = () => {
  const [url, setUrl] = useState('');
  const [anonKey, setAnonKey] = useState('');
  const { saveConfig, isLoading, configError } = useSupabaseConfig();
  const [modalVisible, setModalVisible] = useState(false);

  const handleConnect = async () => {
    const success = await saveConfig(url.trim(), anonKey.trim());
    if (!success) {
      Alert.alert("Connection Failed", configError || "Please check your URL and Anon Key and try again.");
    }
  };

  const handleViewInstruction = () => {
    setModalVisible(true);
  };

  return (
    <ScrollView contentContainerStyle={styles.container}>
      <Text style={styles.title}>Connect to Your Supabase</Text>
      <Text style={styles.instructions}>
        Before using the app, you need to set up your own Supabase project.
        Follow the instructions provided (link below) to create the necessary tables and functions.
        Then, enter your Supabase Project URL and Anon Key below.
      </Text>

      <TextInput
        style={styles.input}
        placeholder="Supabase Project URL (e.g., https://xyz.supabase.co)"
        value={url}
        onChangeText={setUrl}
        autoCapitalize="none"
        keyboardType="url"
      />
      <TextInput
        style={styles.input}
        placeholder="Supabase Anon Key (public)"
        value={anonKey}
        onChangeText={setAnonKey}
        autoCapitalize="none"
        secureTextEntry={true}
      />

      {isLoading && <ActivityIndicator size="large" color="#0066cc" />}
      {configError && <Text style={styles.errorText}>{configError}</Text>}

      <Button title={isLoading ? "Connecting..." : "Connect & Save"} onPress={handleConnect} disabled={isLoading} />

      <Text style={styles.privacyNote}>
        Your URL and Anon Key are stored only in your browser's local storage and are not sent to our servers.
        Ensure you have enabled Row Level Security on your Supabase tables.
      </Text>

      <Button title="View Instructions" onPress={handleViewInstruction} />

      <Modal
        visible={modalVisible}
        animationType="fade"
        onRequestClose={() => setModalVisible(false)}
        transparent={true}
      >
        <View style={styles.modalOverlay}>
          <View style={styles.modalInnerContainer}>
            <View style={styles.modalHeader}>
              <TouchableOpacity onPress={() => setModalVisible(false)} style={styles.modalCloseButton}>
                <Text style={styles.modalCloseButtonText}>✕</Text>
              </TouchableOpacity>
            </View>
            <ScrollView style={styles.modalScrollView}>
              <Markdown style={markdownStyles}>{readmeContent}</Markdown>
            </ScrollView>
          </View>
        </View>
      </Modal>
    </ScrollView>
  );
};

const styles = StyleSheet.create({
  container: {
    flexGrow: 1,
    justifyContent: 'center',
    alignItems: 'center',
    padding: 20,
    backgroundColor: '#f5f5f5',
  },
  title: {
    fontSize: 24,
    fontWeight: 'bold',
    marginBottom: 15,
    textAlign: 'center',
  },
  instructions: {
    textAlign: 'center',
    marginBottom: 20,
    color: '#333',
    lineHeight: 20,
  },
  input: {
    width: '100%',
    height: 50,
    borderColor: '#ccc',
    borderWidth: 1,
    borderRadius: 8,
    paddingHorizontal: 15,
    marginBottom: 15,
    backgroundColor: 'white',
  },
  errorText: {
    color: 'red',
    marginBottom: 10,
    textAlign: 'center',
  },
  privacyNote: {
    marginTop: 25,
    fontSize: 12,
    color: '#666',
    textAlign: 'center',
    fontStyle: 'italic',
  },
  modalOverlay: {
    flex: 1,
    backgroundColor: 'rgba(0, 0, 0, 0.5)',
    justifyContent: 'center',
    alignItems: 'center',
  },
  modalInnerContainer: {
    width: '90%',
    maxHeight: '90%',
    backgroundColor: 'white',
    borderRadius: 10,
    padding: 20,
  },
  modalHeader: {
    flexDirection: 'row',
    justifyContent: 'flex-end',
    marginBottom: 10,
  },
  modalCloseButton: {
    padding: 5,
  },
  modalCloseButtonText: {
    fontSize: 20,
    color: '#666',
  },
  modalScrollView: {
    flex: 1,
  },
});

const markdownStyles = {
  body: {
    color: '#333',
    fontSize: 16,
    lineHeight: 24,
  },
  heading1: {
    fontSize: 24,
    fontWeight: 'bold',
    marginBottom: 20,
    color: '#2c3e50',
  },
  heading2: {
    fontSize: 20,
    fontWeight: 'bold',
    marginTop: 20,
    marginBottom: 10,
    color: '#2c3e50',
  },
  code_inline: {
    backgroundColor: '#f0f0f0',
    padding: 2,
    borderRadius: 4,
    fontFamily: Platform.OS === 'ios' ? 'Menlo' : 'monospace',
  },
  code_block: {
    backgroundColor: '#f0f0f0',
    padding: 10,
    borderRadius: 4,
    marginVertical: 10,
    fontFamily: Platform.OS === 'ios' ? 'Menlo' : 'monospace',
  },
  link: {
    color: '#0066cc',
  },
  list_item: {
    marginBottom: 5,
  },
  strong: {
    fontWeight: 'bold',
    color: '#2c3e50',
  },
  em: {
    fontStyle: 'italic',
  },
  hr: {
    backgroundColor: '#ccc',
    height: 0.5,
    marginVertical: 20,
    opacity: 0.5,
  },
};

export default SetupScreen;
